{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/ens/getEnsAddress.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/ens/getEnsAddress.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  addressResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type TrimErrorType, trim } from '../../utils/data/trim.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsAddressParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /**\n     * ENSIP-9 compliant coinType (chain) to get ENS address for.\n     *\n     * To get the `coinType` for a chain id, use the `toCoinType` function:\n     * ```ts\n     * import { toCoinType } from 'viem'\n     * import { base } from 'viem/chains'\n     *\n     * const coinType = toCoinType(base.id)\n     * ```\n     *\n     * @default 60n\n     */\n    coinType?: bigint | undefined\n    /**\n     * Universal Resolver gateway URLs to use for resolving CCIP-read requests.\n     */\n    gatewayUrls?: string[] | undefined\n    /**\n     * Name to get the address for.\n     */\n    name: string\n    /**\n     * Whether or not to throw errors propagated from the ENS Universal Resolver Contract.\n     */\n    strict?: boolean | undefined\n    /**\n     * Address of ENS Universal Resolver Contract.\n     */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsAddressReturnType = Address | null\n\nexport type GetEnsAddressErrorType =\n  | GetChainContractAddressErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | DecodeFunctionResultErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsAddressParameters,\n): Promise<GetEnsAddressReturnType> {\n  const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } =\n    parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null\n\n  const args = (() => {\n    if (coinType != null) return [namehash(name), BigInt(coinType)] as const\n    return [namehash(name)] as const\n  })()\n\n  try {\n    const functionData = encodeFunctionData({\n      abi: addressResolverAbi,\n      functionName: 'addr',\n      args,\n    })\n\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolveWithGateways',\n      args: [\n        toHex(packetToBytes(name)),\n        functionData,\n        gatewayUrls ?? [localBatchGatewayUrl],\n      ],\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const address = decodeFunctionResult({\n      abi: addressResolverAbi,\n      args,\n      functionName: 'addr',\n      data: res[0],\n    })\n\n    if (address === '0x') return null\n    if (trim(address) === '0x00') return null\n    return address\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/ens/getEnsText.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/ens/getEnsText.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  textResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsTextParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENS name to get Text for. */\n    name: string\n    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */\n    gatewayUrls?: string[] | undefined\n    /** Text record to retrieve. */\n    key: string\n    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */\n    strict?: boolean | undefined\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsTextReturnType = string | null\n\nexport type GetEnsTextErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | DecodeFunctionResultErrorType\n\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wevm.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wevm_dev'\n */\nexport async function getEnsText<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsTextParameters,\n): Promise<GetEnsTextReturnType> {\n  const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null\n\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      args: [\n        toHex(packetToBytes(name)),\n        encodeFunctionData({\n          abi: textResolverAbi,\n          functionName: 'text',\n          args: [namehash(name), key],\n        }),\n        gatewayUrls ?? [localBatchGatewayUrl],\n      ],\n      functionName: 'resolveWithGateways',\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const record = decodeFunctionResult({\n      abi: textResolverAbi,\n      functionName: 'text',\n      data: res[0],\n    })\n\n    return record === '' ? null : record\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/ens/getEnsAvatar.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/ens/getEnsAvatar.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../types/ens.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type ParseAvatarRecordErrorType,\n  parseAvatarRecord,\n} from '../../utils/ens/avatar/parseAvatarRecord.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport {\n  type GetEnsTextErrorType,\n  type GetEnsTextParameters,\n  getEnsText,\n} from './getEnsText.js'\n\nexport type GetEnsAvatarParameters = Prettify<\n  Omit<GetEnsTextParameters, 'key'> & {\n    /** Gateway urls to resolve IPFS and/or Arweave assets. */\n    assetGatewayUrls?: AssetGatewayUrls | undefined\n  }\n>\n\nexport type GetEnsAvatarReturnType = string | null\n\nexport type GetEnsAvatarErrorType =\n  | GetEnsTextErrorType\n  | ParseAvatarRecordErrorType\n  | ErrorType\n\n/**\n * Gets the avatar of an ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAvatarParameters}\n * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAvatar, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAvatar = await getEnsAvatar(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'\n */\nexport async function getEnsAvatar<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    assetGatewayUrls,\n    name,\n    gatewayUrls,\n    strict,\n    universalResolverAddress,\n  }: GetEnsAvatarParameters,\n): Promise<GetEnsAvatarReturnType> {\n  const record = await getAction(\n    client,\n    getEnsText,\n    'getEnsText',\n  )({\n    blockNumber,\n    blockTag,\n    key: 'avatar',\n    name,\n    universalResolverAddress,\n    gatewayUrls,\n    strict,\n  })\n  if (!record) return null\n  try {\n    return await parseAvatarRecord(client, {\n      record,\n      gatewayUrls: assetGatewayUrls,\n    })\n  } catch {\n    return null\n  }\n}\n"],"names":[],"mappings":";;;;AAMA,OAAO,EAEL,iBAAiB,GAClB,MAAM,6CAA6C,CAAA;AACpD,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AAEpD,OAAO,EAGL,UAAU,GACX,MAAM,iBAAiB,CAAA;;;;AA4CjB,KAAK,UAAU,YAAY,CAChC,MAAgC,EAChC,EACE,WAAW,EACX,QAAQ,EACR,gBAAgB,EAChB,IAAI,EACJ,WAAW,EACX,MAAM,EACN,wBAAwB,EACD;IAEzB,MAAM,MAAM,GAAG,UAAM,kKAAS,EAC5B,MAAM,EACN,6KAAU,EACV,YAAY,CACb,CAAC;QACA,WAAW;QACX,QAAQ;QACR,GAAG,EAAE,QAAQ;QACb,IAAI;QACJ,wBAAwB;QACxB,WAAW;QACX,MAAM;KACP,CAAC,CAAA;IACF,IAAI,CAAC,MAAM,EAAE,OAAO,IAAI,CAAA;IACxB,IAAI,CAAC;QACH,OAAO,UAAM,mMAAiB,EAAC,MAAM,EAAE;YACrC,MAAM;YACN,WAAW,EAAE,gBAAgB;SAC9B,CAAC,CAAA;IACJ,CAAC,CAAC,OAAM,CAAC;QACP,OAAO,IAAI,CAAA;IACb,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 212, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/ens/getEnsName.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/ens/getEnsName.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalResolverReverseAbi } from '../../constants/abis.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport type { PacketToBytesErrorType } from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsNameParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /**\n     * Address to get ENS name for.\n     */\n    address: Address\n    /**\n     * ENSIP-9 compliant coinType (chain) to get ENS name for.\n     *\n     * To get the `coinType` for a chain id, use the `toCoinType` function:\n     * ```ts\n     * import { toCoinType } from 'viem'\n     * import { base } from 'viem/chains'\n     *\n     * const coinType = toCoinType(base.id)\n     * ```\n     *\n     * @default 60n\n     */\n    coinType?: bigint | undefined\n    /**\n     * Universal Resolver gateway URLs to use for resolving CCIP-read requests.\n     */\n    gatewayUrls?: string[] | undefined\n    /**\n     * Whether or not to throw errors propagated from the ENS Universal Resolver Contract.\n     */\n    strict?: boolean | undefined\n    /**\n     * Address of ENS Universal Resolver Contract.\n     */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsNameReturnType = string | null\n\nexport type GetEnsNameErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets primary name for specified address.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsName\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `reverse(bytes)` on ENS Universal Resolver Contract to \"reverse resolve\" the address to the primary ENS name.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsNameParameters}\n * @returns Name or `null` if not found. {@link GetEnsNameReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsName } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensName = await getEnsName(client, {\n *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n * })\n * // 'wevm.eth'\n */\nexport async function getEnsName<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsNameParameters,\n): Promise<GetEnsNameReturnType> {\n  const {\n    address,\n    blockNumber,\n    blockTag,\n    coinType = 60n,\n    gatewayUrls,\n    strict,\n  } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverReverseAbi,\n      args: [address, coinType, gatewayUrls ?? [localBatchGatewayUrl]],\n      functionName: 'reverseWithGateways',\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const [name] = await readContractAction(readContractParameters)\n\n    return name || null\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n"],"names":[],"mappings":";;;;AAIA,OAAO,EAAE,2BAA2B,EAAE,MAAM,yBAAyB,CAAA;AAIrE,OAAO,EAEL,uBAAuB,GACxB,MAAM,8CAA8C,CAAA;AACrD,OAAO,EAAE,4BAA4B,EAAE,MAAM,2BAA2B,CAAA;AACxE,OAAO,EAAE,oBAAoB,EAAE,MAAM,6CAA6C,CAAA;AAElF,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAGL,YAAY,GACb,MAAM,2BAA2B,CAAA;;;;;;;AAuE3B,KAAK,UAAU,UAAU,CAC9B,MAAgC,EAChC,UAAgC;IAEhC,MAAM,EACJ,OAAO,EACP,WAAW,EACX,QAAQ,EACR,QAAQ,GAAG,GAAG,EACd,WAAW,EACX,MAAM,EACP,GAAG,UAAU,CAAA;IACd,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,CAAA;IAExB,MAAM,wBAAwB,GAAG,CAAC,GAAG,EAAE;QACrC,IAAI,UAAU,CAAC,wBAAwB,EACrC,OAAO,UAAU,CAAC,wBAAwB,CAAA;QAC5C,IAAI,CAAC,KAAK,EACR,MAAM,IAAI,KAAK,CACb,oEAAoE,CACrE,CAAA;QACH,WAAO,uMAAuB,EAAC;YAC7B,WAAW;YACX,KAAK;YACL,QAAQ,EAAE,sBAAsB;SACjC,CAAC,CAAA;IACJ,CAAC,CAAC,EAAE,CAAA;IAEJ,IAAI,CAAC;QACH,MAAM,sBAAsB,GAAG;YAC7B,OAAO,EAAE,wBAAwB;YACjC,GAAG,EAAE,mLAA2B;YAChC,IAAI,EAAE;gBAAC,OAAO;gBAAE,QAAQ;gBAAE,WAAW,IAAI;oBAAC,mMAAoB;iBAAC;aAAC;YAChE,YAAY,EAAE,qBAAqB;YACnC,WAAW;YACX,QAAQ;SACA,CAAA;QAEV,MAAM,kBAAkB,OAAG,kKAAS,EAAC,MAAM,EAAE,oLAAY,EAAE,cAAc,CAAC,CAAA;QAE1E,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,kBAAkB,CAAC,sBAAsB,CAAC,CAAA;QAE/D,OAAO,IAAI,IAAI,IAAI,CAAA;IACrB,CAAC,CAAC,OAAO,GAAG,EAAE,CAAC;QACb,IAAI,MAAM,EAAE,MAAM,GAAG,CAAA;QACrB,QAAI,yLAA4B,EAAC,GAAG,CAAC,EAAE,OAAO,IAAI,CAAA;QAClD,MAAM,GAAG,CAAA;IACX,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/ens/getEnsResolver.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/ens/getEnsResolver.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsResolverParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsResolverReturnType = Address\n\nexport type GetEnsResolverErrorType =\n  | GetChainContractAddressErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsResolverParameters,\n): Promise<GetEnsResolverReturnType> {\n  const { blockNumber, blockTag, name } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n    throw new Error(\n      `${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`,\n    )\n\n  const [resolverAddress] = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address: universalResolverAddress,\n    abi: [\n      {\n        inputs: [{ type: 'bytes' }],\n        name: 'findResolver',\n        outputs: [\n          { type: 'address' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n      },\n    ],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag,\n  })\n  return resolverAddress\n}\n"],"names":[],"mappings":";;;;AAOA,OAAO,EAEL,uBAAuB,GACxB,MAAM,8CAA8C,CAAA;AACrD,OAAO,EAAuB,KAAK,EAAE,MAAM,+BAA+B,CAAA;AAC1E,OAAO,EAEL,aAAa,GACd,MAAM,kCAAkC,CAAA;AACzC,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAEL,YAAY,GACb,MAAM,2BAA2B,CAAA;;;;;;AA+C3B,KAAK,UAAU,cAAc,CAClC,MAAgC,EAChC,UAAoC;IAEpC,MAAM,EAAE,WAAW,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,UAAU,CAAA;IAClD,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,CAAA;IAExB,MAAM,wBAAwB,GAAG,CAAC,GAAG,EAAE;QACrC,IAAI,UAAU,CAAC,wBAAwB,EACrC,OAAO,UAAU,CAAC,wBAAwB,CAAA;QAC5C,IAAI,CAAC,KAAK,EACR,MAAM,IAAI,KAAK,CACb,oEAAoE,CACrE,CAAA;QACH,WAAO,uMAAuB,EAAC;YAC7B,WAAW;YACX,KAAK;YACL,QAAQ,EAAE,sBAAsB;SACjC,CAAC,CAAA;IACJ,CAAC,CAAC,EAAE,CAAA;IAEJ,MAAM,IAAI,GAAG,KAAK,EAAE,OAAO,CAAA;IAC3B,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,GAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EACjD,MAAM,IAAI,KAAK,CACb,GAAG,IAAI,CAAA,yBAAA,EAA4B,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,CAAA,aAAA,EAAgB,KAAK,CAAC,IAAI,CAAA,OAAA,EAAU,KAAK,CAAC,EAAE,CAAA,EAAA,CAAI,CACpG,CAAA;IAEH,MAAM,CAAC,eAAe,CAAC,GAAG,UAAM,kKAAS,EACvC,MAAM,EACN,oLAAY,EACZ,cAAc,CACf,CAAC;QACA,OAAO,EAAE,wBAAwB;QACjC,GAAG,EAAE;YACH;gBACE,MAAM,EAAE;oBAAC;wBAAE,IAAI,EAAE,OAAO;oBAAA,CAAE;iBAAC;gBAC3B,IAAI,EAAE,cAAc;gBACpB,OAAO,EAAE;oBACP;wBAAE,IAAI,EAAE,SAAS;oBAAA,CAAE;oBACnB;wBAAE,IAAI,EAAE,SAAS;oBAAA,CAAE;oBACnB;wBAAE,IAAI,EAAE,SAAS;oBAAA,CAAE;iBACpB;gBACD,eAAe,EAAE,MAAM;gBACvB,IAAI,EAAE,UAAU;aACjB;SACF;QACD,YAAY,EAAE,cAAc;QAC5B,IAAI,EAAE;gBAAC,sKAAK,MAAC,iLAAa,EAAC,IAAI,CAAC,CAAC;SAAC;QAClC,WAAW;QACX,QAAQ;KACT,CAAC,CAAA;IACF,OAAO,eAAe,CAAA;AACxB,CAAC","debugId":null}},
    {"offset": {"line": 334, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/createAccessList.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/createAccessList.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { AccessList, TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, Prettify, UnionOmit } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetCallErrorReturnType,\n  getCallError,\n} from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport type {\n  AssertRequestErrorType,\n  AssertRequestParameters,\n} from '../../utils/transaction/assertRequest.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\n\nexport type CreateAccessListParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<\n  FormattedTransactionRequest<chain>,\n  'from' | 'nonce' | 'accessList'\n> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\n\nexport type CreateAccessListReturnType = Prettify<{\n  accessList: AccessList\n  gasUsed: bigint\n}>\n\nexport type CreateAccessListErrorType = GetCallErrorReturnType<\n  | ParseAccountErrorType\n  | AssertRequestErrorType\n  | NumberToHexErrorType\n  | FormatTransactionRequestErrorType\n  | RequestErrorType\n>\n\n/**\n * Creates an EIP-2930 access list.\n *\n * - Docs: https://viem.sh/docs/actions/public/createAccessList\n * - JSON-RPC Methods: `eth_createAccessList`\n *\n * @param client - Client to use\n * @param parameters - {@link CreateAccessListParameters}\n * @returns The access list. {@link CreateAccessListReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createAccessList } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await createAccessList(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function createAccessList<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  args: CreateAccessListParameters<chain>,\n): Promise<CreateAccessListReturnType> {\n  const {\n    account: account_ = client.account,\n    blockNumber,\n    blockTag = 'latest',\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    to,\n    value,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format(\n      {\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        account,\n        blobs,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        to,\n        value,\n      } as TransactionRequest,\n      'createAccessList',\n    ) as TransactionRequest\n\n    const response = await client.request({\n      method: 'eth_createAccessList',\n      params: [request as ExactPartial<RpcTransactionRequest>, block],\n    })\n    return {\n      accessList: response.accessList,\n      gasUsed: BigInt(response.gasUsed),\n    }\n  } catch (err) {\n    throw getCallError(err as ErrorType, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n"],"names":[],"mappings":";;;;AAGA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAU7C,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;AACtC,OAAO,EAEL,YAAY,GACb,MAAM,oCAAoC,CAAA;AAC3C,OAAO,EAAE,OAAO,EAAE,MAAM,mCAAmC,CAAA;AAC3D,OAAO,EAGL,wBAAwB,GACzB,MAAM,8CAA8C,CAAA;AAKrD,OAAO,EAAE,aAAa,EAAE,MAAM,0CAA0C,CAAA;;;;;;;AAgEjE,KAAK,UAAU,gBAAgB,CACpC,MAAgC,EAChC,IAAuC;IAEvC,MAAM,EACJ,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAClC,WAAW,EACX,QAAQ,GAAG,QAAQ,EACnB,KAAK,EACL,IAAI,EACJ,GAAG,EACH,QAAQ,EACR,gBAAgB,EAChB,YAAY,EACZ,oBAAoB,EACpB,EAAE,EACF,KAAK,EACL,GAAG,IAAI,EACR,GAAG,IAAI,CAAA;IACR,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,KAAC,oLAAY,EAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IAE7D,IAAI,CAAC;YACH,yLAAa,EAAC,IAA+B,CAAC,CAAA;QAE9C,MAAM,cAAc,GAClB,OAAO,WAAW,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;QACxE,MAAM,KAAK,GAAG,cAAc,IAAI,QAAQ,CAAA;QAExC,MAAM,WAAW,GAAG,MAAM,CAAC,KAAK,EAAE,UAAU,EAAE,kBAAkB,EAAE,MAAM,CAAA;QACxE,MAAM,MAAM,GAAG,WAAW,IAAI,wMAAwB,CAAA;QAEtD,MAAM,OAAO,GAAG,MAAM,CACpB;YACE,gFAAgF;YAChF,OAAG,4KAAO,EAAC,IAAI,EAAE;gBAAE,MAAM,EAAE,WAAW;YAAA,CAAE,CAAC;YACzC,OAAO;YACP,KAAK;YACL,IAAI;YACJ,GAAG;YACH,QAAQ;YACR,gBAAgB;YAChB,YAAY;YACZ,oBAAoB;YACpB,EAAE;YACF,KAAK;SACgB,EACvB,kBAAkB,CACG,CAAA;QAEvB,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;YACpC,MAAM,EAAE,sBAAsB;YAC9B,MAAM,EAAE;gBAAC,OAA8C;gBAAE,KAAK;aAAC;SAChE,CAAC,CAAA;QACF,OAAO;YACL,UAAU,EAAE,QAAQ,CAAC,UAAU;YAC/B,OAAO,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC;SAClC,CAAA;IACH,CAAC,CAAC,OAAO,GAAG,EAAE,CAAC;QACb,UAAM,kLAAY,EAAC,GAAgB,EAAE;YACnC,GAAG,IAAI;YACP,OAAO;YACP,KAAK,EAAE,MAAM,CAAC,KAAK;SACpB,CAAC,CAAA;IACJ,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 398, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/createBlockFilter.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/createBlockFilter.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateBlockFilterReturnType = Filter<'block'>\n\nexport type CreateBlockFilterErrorType = RequestErrorType | ErrorType\n\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createBlockFilter\n * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'block' }\n */\nexport async function createBlockFilter<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n): Promise<CreateBlockFilterReturnType> {\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newBlockFilter',\n  })\n  const id = await client.request({\n    method: 'eth_newBlockFilter',\n  })\n  return { id, request: getRequest(id), type: 'block' }\n}\n"],"names":[],"mappings":";;;;AAMA,OAAO,EAAE,wBAAwB,EAAE,MAAM,iDAAiD,CAAA;;AA2BnF,KAAK,UAAU,iBAAiB,CACrC,MAAgC;IAEhC,MAAM,UAAU,OAAG,2MAAwB,EAAC,MAAM,EAAE;QAClD,MAAM,EAAE,oBAAoB;KAC7B,CAAC,CAAA;IACF,MAAM,EAAE,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QAC9B,MAAM,EAAE,oBAAoB;KAC7B,CAAC,CAAA;IACF,OAAO;QAAE,EAAE;QAAE,OAAO,EAAE,UAAU,CAAC,EAAE,CAAC;QAAE,IAAI,EAAE,OAAO;IAAA,CAAE,CAAA;AACvD,CAAC","debugId":null}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/createContractEventFilter.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/createContractEventFilter.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateContractEventFilterParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  args extends\n    | MaybeExtractEventArgsFromAbi<abi, eventName>\n    | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  address?: Address | Address[] | undefined\n  abi: abi\n  eventName?: eventName | ContractEventName<abi> | undefined\n  fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments in the event ABI item.\n   * @default false\n   */\n  strict?: strict | boolean | undefined\n  toBlock?: toBlock | BlockNumber | BlockTag | undefined\n} & (undefined extends eventName\n  ? {\n      args?: undefined\n    }\n  : MaybeExtractEventArgsFromAbi<abi, eventName> extends infer eventFilterArgs\n    ? {\n        args?:\n          | eventFilterArgs\n          | (args extends eventFilterArgs ? args : never)\n          | undefined\n      }\n    : {\n        args?: undefined\n      })\n\nexport type CreateContractEventFilterReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  args extends\n    | MaybeExtractEventArgsFromAbi<abi, eventName>\n    | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = Filter<'event', abi, eventName, args, strict, fromBlock, toBlock>\n\nexport type CreateContractEventFilterErrorType =\n  | EncodeEventTopicsErrorType\n  | RequestErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).\n *\n * - Docs: https://viem.sh/docs/contract/createContractEventFilter\n *\n * @param client - Client to use\n * @param parameters - {@link CreateContractEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateContractEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n * })\n */\nexport async function createContractEventFilter<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined,\n  args extends MaybeExtractEventArgsFromAbi<abi, eventName> | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: CreateContractEventFilterParameters<\n    abi,\n    eventName,\n    args,\n    strict,\n    fromBlock,\n    toBlock\n  >,\n): Promise<\n  CreateContractEventFilterReturnType<\n    abi,\n    eventName,\n    args,\n    strict,\n    fromBlock,\n    toBlock\n  >\n> {\n  const { address, abi, args, eventName, fromBlock, strict, toBlock } =\n    parameters as CreateContractEventFilterParameters\n\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter',\n  })\n\n  const topics = eventName\n    ? encodeEventTopics({\n        abi,\n        args,\n        eventName,\n      } as unknown as EncodeEventTopicsParameters)\n    : undefined\n  const id: Hex = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        topics,\n      },\n    ],\n  })\n\n  return {\n    abi,\n    args,\n    eventName,\n    id,\n    request: getRequest(id),\n    strict: Boolean(strict),\n    type: 'event',\n  } as unknown as CreateContractEventFilterReturnType<\n    abi,\n    eventName,\n    args,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n"],"names":[],"mappings":";;;;AAaA,OAAO,EAGL,iBAAiB,GAClB,MAAM,sCAAsC,CAAA;AAE7C,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;AACtC,OAAO,EAAE,wBAAwB,EAAE,MAAM,iDAAiD,CAAA;;;;AA4EnF,KAAK,UAAU,yBAAyB,CAS7C,MAAgC,EAChC,UAOC;IAWD,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,GACjE,UAAiD,CAAA;IAEnD,MAAM,UAAU,OAAG,2MAAwB,EAAC,MAAM,EAAE;QAClD,MAAM,EAAE,eAAe;KACxB,CAAC,CAAA;IAEF,MAAM,MAAM,GAAG,SAAS,OACpB,yLAAiB,EAAC;QAChB,GAAG;QACH,IAAI;QACJ,SAAS;KACgC,CAAC,GAC5C,SAAS,CAAA;IACb,MAAM,EAAE,GAAQ,MAAM,MAAM,CAAC,OAAO,CAAC;QACnC,MAAM,EAAE,eAAe;QACvB,MAAM,EAAE;YACN;gBACE,OAAO;gBACP,SAAS,EACP,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS;gBACpE,OAAO,EAAE,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO;gBACrE,MAAM;aACP;SACF;KACF,CAAC,CAAA;IAEF,OAAO;QACL,GAAG;QACH,IAAI;QACJ,SAAS;QACT,EAAE;QACF,OAAO,EAAE,UAAU,CAAC,EAAE,CAAC;QACvB,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC;QACvB,IAAI,EAAE,OAAO;KAQd,CAAA;AACH,CAAC","debugId":null}},
    {"offset": {"line": 466, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/createEventFilter.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/createEventFilter.ts"],"sourcesContent":["import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hex, LogTopic } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateEventFilterParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n> = {\n  address?: Address | Address[] | undefined\n  fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n  toBlock?: toBlock | BlockNumber | BlockTag | undefined\n} & (MaybeExtractEventArgsFromAbi<\n  abiEvents,\n  _eventName\n> extends infer eventFilterArgs\n  ?\n      | {\n          args:\n            | eventFilterArgs\n            | (_args extends eventFilterArgs ? _args : never)\n          event: abiEvent\n          events?: undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: abiEvent | undefined\n          events?: undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: undefined\n          events: abiEvents | undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: undefined\n          events?: undefined\n          strict?: undefined\n        }\n  : {\n      args?: undefined\n      event?: undefined\n      events?: undefined\n      strict?: undefined\n    })\n\nexport type CreateEventFilterReturnType<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n> = Prettify<\n  Filter<'event', abiEvents, _eventName, _args, strict, fromBlock, toBlock>\n>\n\nexport type CreateEventFilterErrorType =\n  | EncodeEventTopicsErrorType\n  | RequestErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createEventFilter\n * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n *\n * @param client - Client to use\n * @param parameters - {@link CreateEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * })\n */\nexport async function createEventFilter<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    args,\n    event,\n    events: events_,\n    fromBlock,\n    strict,\n    toBlock,\n  }: CreateEventFilterParameters<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  > = {} as any,\n): Promise<\n  CreateEventFilterReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  >\n> {\n  const events = events_ ?? (event ? [event] : undefined)\n\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter',\n  })\n\n  let topics: LogTopic[] = []\n  if (events) {\n    const encoded = (events as AbiEvent[]).flatMap((event) =>\n      encodeEventTopics({\n        abi: [event],\n        eventName: (event as AbiEvent).name,\n        args,\n      } as EncodeEventTopicsParameters),\n    )\n    // TODO: Clean up type casting\n    topics = [encoded as LogTopic]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  const id: Hex = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        ...(topics.length ? { topics } : {}),\n      },\n    ],\n  })\n\n  return {\n    abi: events,\n    args,\n    eventName: event ? (event as AbiEvent).name : undefined,\n    fromBlock,\n    id,\n    request: getRequest(id),\n    strict: Boolean(strict),\n    toBlock,\n    type: 'event',\n  } as unknown as CreateEventFilterReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  >\n}\n"],"names":[],"mappings":";;;;AAcA,OAAO,EAGL,iBAAiB,GAClB,MAAM,sCAAsC,CAAA;AAE7C,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;AACtC,OAAO,EAAE,wBAAwB,EAAE,MAAM,iDAAiD,CAAA;;;;AAoHnF,KAAK,UAAU,iBAAiB,CAerC,MAAgC,EAChC,EACE,OAAO,EACP,IAAI,EACJ,KAAK,EACL,MAAM,EAAE,OAAO,EACf,SAAS,EACT,MAAM,EACN,OAAO,EAAA,GASL,CAAA,CAAS;IAYb,MAAM,MAAM,GAAG,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAAC,KAAK;KAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAA;IAEvD,MAAM,UAAU,OAAG,2MAAwB,EAAC,MAAM,EAAE;QAClD,MAAM,EAAE,eAAe;KACxB,CAAC,CAAA;IAEF,IAAI,MAAM,GAAe,EAAE,CAAA;IAC3B,IAAI,MAAM,EAAE,CAAC;QACX,MAAM,OAAO,GAAI,MAAqB,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CACrD,CADuD,gBACtC,8KAAC;gBAChB,GAAG,EAAE;oBAAC,KAAK;iBAAC;gBACZ,SAAS,EAAG,KAAkB,CAAC,IAAI;gBACnC,IAAI;aAC0B,CAAC,CAClC,CAAA;QACD,8BAA8B;QAC9B,MAAM,GAAG;YAAC,OAAmB;SAAC,CAAA;QAC9B,IAAI,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC,CAAe,CAAA;IAC7C,CAAC;IAED,MAAM,EAAE,GAAQ,MAAM,MAAM,CAAC,OAAO,CAAC;QACnC,MAAM,EAAE,eAAe;QACvB,MAAM,EAAE;YACN;gBACE,OAAO;gBACP,SAAS,EACP,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS;gBACpE,OAAO,EAAE,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO;gBACrE,GAAG,AAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;oBAAE,MAAM;gBAAA,CAAE,CAAC,CAAC,CAAC,CAAA,CAAE,CAAC;aACrC;SACF;KACF,CAAC,CAAA;IAEF,OAAO;QACL,GAAG,EAAE,MAAM;QACX,IAAI;QACJ,SAAS,EAAE,KAAK,CAAC,CAAC,CAAE,KAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS;QACvD,SAAS;QACT,EAAE;QACF,OAAO,EAAE,UAAU,CAAC,EAAE,CAAC;QACvB,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC;QACvB,OAAO;QACP,IAAI,EAAE,OAAO;KASd,CAAA;AACH,CAAC","debugId":null}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/estimateContractGas.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/estimateContractGas.ts"],"sourcesContent":["import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  GetValue,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  estimateGas,\n} from './estimateGas.js'\n\nexport type EstimateContractGasParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<EstimateGasParameters<chain>, 'data' | 'to' | 'value'> &\n  GetValue<\n    abi,\n    functionName,\n    EstimateGasParameters<chain> extends EstimateGasParameters\n      ? EstimateGasParameters<chain>['value']\n      : EstimateGasParameters['value']\n  > & {\n    /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n    dataSuffix?: Hex | undefined\n  }\n\nexport type EstimateContractGasReturnType = bigint\n\nexport type EstimateContractGasErrorType = GetContractErrorReturnType<\n  EncodeFunctionDataErrorType | EstimateGasErrorType | ParseAccountErrorType\n>\n\n/**\n * Estimates the gas required to successfully execute a contract write function call.\n *\n * - Docs: https://viem.sh/docs/contract/estimateContractGas\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateContractGas } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gas = await estimateContractGas(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractGas<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateContractGasParameters<abi, functionName, args, chain>,\n): Promise<EstimateContractGasReturnType> {\n  const { abi, address, args, functionName, dataSuffix, ...request } =\n    parameters as EstimateContractGasParameters\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const gas = await getAction(\n      client,\n      estimateGas,\n      'estimateGas',\n    )({\n      data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...request,\n    } as unknown as EstimateGasParameters)\n    return gas\n  } catch (error) {\n    const account = request.account ? parseAccount(request.account) : undefined\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/estimateContractGas',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n"],"names":[],"mappings":";;;;AAGA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAa7C,OAAO,EAGL,kBAAkB,GACnB,MAAM,uCAAuC,CAAA;AAC9C,OAAO,EAEL,gBAAgB,GACjB,MAAM,wCAAwC,CAAA;AAC/C,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAGL,WAAW,GACZ,MAAM,kBAAkB,CAAA;;;;;;AAiElB,KAAK,UAAU,mBAAmB,CAOvC,MAAyC,EACzC,UAAyE;IAEzE,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,UAAU,EAAE,GAAG,OAAO,EAAE,GAChE,UAA2C,CAAA;IAC7C,MAAM,IAAI,OAAG,2LAAkB,EAAC;QAC9B,GAAG;QACH,IAAI;QACJ,YAAY;KACmB,CAAC,CAAA;IAClC,IAAI,CAAC;QACH,MAAM,GAAG,GAAG,UAAM,kKAAS,EACzB,MAAM,EACN,kLAAW,EACX,aAAa,CACd,CAAC;YACA,IAAI,EAAE,GAAG,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE;YAChE,EAAE,EAAE,OAAO;YACX,GAAG,OAAO;SACyB,CAAC,CAAA;QACtC,OAAO,GAAG,CAAA;IACZ,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,KAAC,oLAAY,EAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;QAC3E,UAAM,0LAAgB,EAAC,KAAkB,EAAE;YACzC,GAAG;YACH,OAAO;YACP,IAAI;YACJ,QAAQ,EAAE,oCAAoC;YAC9C,YAAY;YACZ,MAAM,EAAE,OAAO,EAAE,OAAO;SACzB,CAAC,CAAA;IACJ,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 571, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getBlobBaseFee.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getBlobBaseFee.ts"],"sourcesContent":["import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetBlobBaseFeeReturnType = bigint\n\nexport type GetBlobBaseFeeErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the base fee per blob gas in wei.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlobBaseFee\n * - JSON-RPC Methods: [`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blobBaseFee)\n *\n * @param client - Client to use\n * @returns The blob base fee (in wei). {@link GetBlobBaseFeeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlobBaseFee } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const blobBaseFee = await getBlobBaseFee(client)\n */\nexport async function getBlobBaseFee<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n): Promise<GetBlobBaseFeeReturnType> {\n  const baseFee = await client.request({\n    method: 'eth_blobBaseFee',\n  })\n  return BigInt(baseFee)\n}\n"],"names":[],"mappings":"AAWA;;;;;;;;;;;;;;;;;;;GAmBG;;;;AACI,KAAK,UAAU,cAAc,CAIlC,MAAyC;IAEzC,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QACnC,MAAM,EAAE,iBAAiB;KAC1B,CAAC,CAAA;IACF,OAAO,MAAM,CAAC,OAAO,CAAC,CAAA;AACxB,CAAC","debugId":null}},
    {"offset": {"line": 604, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getBlockTransactionCount.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getBlockTransactionCount.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Quantity } from '../../types/rpc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToNumberErrorType,\n  hexToNumber,\n} from '../../utils/encoding/fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetBlockTransactionCountParameters =\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash | undefined\n      blockNumber?: undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      blockNumber?: undefined\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag | undefined\n    }\n\nexport type GetBlockTransactionCountReturnType = number\n\nexport type GetBlockTransactionCountErrorType =\n  | NumberToHexErrorType\n  | HexToNumberErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the number of Transactions at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockTransactionCountParameters}\n * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const count = await getBlockTransactionCount(client)\n */\nexport async function getBlockTransactionCount<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag = 'latest',\n  }: GetBlockTransactionCountParameters = {},\n): Promise<GetBlockTransactionCountReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let count: Quantity\n  if (blockHash) {\n    count = await client.request(\n      {\n        method: 'eth_getBlockTransactionCountByHash',\n        params: [blockHash],\n      },\n      { dedupe: true },\n    )\n  } else {\n    count = await client.request(\n      {\n        method: 'eth_getBlockTransactionCountByNumber',\n        params: [blockNumberHex || blockTag],\n      },\n      { dedupe: Boolean(blockNumberHex) },\n    )\n  }\n\n  return hexToNumber(count)\n}\n"],"names":[],"mappings":";;;;AAQA,OAAO,EAEL,WAAW,GACZ,MAAM,iCAAiC,CAAA;AACxC,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;;;AAqD/B,KAAK,UAAU,wBAAwB,CAC5C,MAAgC,EAChC,EACE,SAAS,EACT,WAAW,EACX,QAAQ,GAAG,QAAQ,EAAA,GACmB,CAAA,CAAE;IAE1C,MAAM,cAAc,GAClB,WAAW,KAAK,SAAS,CAAC,CAAC,KAAC,4KAAW,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IAElE,IAAI,KAAe,CAAA;IACnB,IAAI,SAAS,EAAE,CAAC;QACd,KAAK,GAAG,MAAM,MAAM,CAAC,OAAO,CAC1B;YACE,MAAM,EAAE,oCAAoC;YAC5C,MAAM,EAAE;gBAAC,SAAS;aAAC;SACpB,EACD;YAAE,MAAM,EAAE,IAAI;QAAA,CAAE,CACjB,CAAA;IACH,CAAC,MAAM,CAAC;QACN,KAAK,GAAG,MAAM,MAAM,CAAC,OAAO,CAC1B;YACE,MAAM,EAAE,sCAAsC;YAC9C,MAAM,EAAE;gBAAC,cAAc,IAAI,QAAQ;aAAC;SACrC,EACD;YAAE,MAAM,EAAE,OAAO,CAAC,cAAc,CAAC;QAAA,CAAE,CACpC,CAAA;IACH,CAAC;IAED,WAAO,8KAAW,EAAC,KAAK,CAAC,CAAA;AAC3B,CAAC","debugId":null}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getCode.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getCode.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetCodeParameters = {\n  address: Address\n} & (\n  | {\n      blockNumber?: undefined\n      blockTag?: BlockTag | undefined\n    }\n  | {\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n)\n\nexport type GetCodeReturnType = Hex | undefined\n\nexport type GetCodeErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Retrieves the bytecode at an address.\n *\n * - Docs: https://viem.sh/docs/contract/getCode\n * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)\n *\n * @param client - Client to use\n * @param parameters - {@link GetCodeParameters}\n * @returns The contract's bytecode. {@link GetCodeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCode } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getCode(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n * })\n */\nexport async function getCode<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { address, blockNumber, blockTag = 'latest' }: GetCodeParameters,\n): Promise<GetCodeReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const hex = await client.request(\n    {\n      method: 'eth_getCode',\n      params: [address, blockNumberHex || blockTag],\n    },\n    { dedupe: Boolean(blockNumberHex) },\n  )\n  if (hex === '0x') return undefined\n  return hex\n}\n"],"names":[],"mappings":";;;;AASA,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;;AA6C/B,KAAK,UAAU,OAAO,CAC3B,MAAgC,EAChC,EAAE,OAAO,EAAE,WAAW,EAAE,QAAQ,GAAG,QAAQ,EAAqB;IAEhE,MAAM,cAAc,GAClB,WAAW,KAAK,SAAS,CAAC,CAAC,KAAC,4KAAW,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IAClE,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,OAAO,CAC9B;QACE,MAAM,EAAE,aAAa;QACrB,MAAM,EAAE;YAAC,OAAO;YAAE,cAAc,IAAI,QAAQ;SAAC;KAC9C,EACD;QAAE,MAAM,EAAE,OAAO,CAAC,cAAc,CAAC;IAAA,CAAE,CACpC,CAAA;IACD,IAAI,GAAG,KAAK,IAAI,EAAE,OAAO,SAAS,CAAA;IAClC,OAAO,GAAG,CAAA;AACZ,CAAC","debugId":null}},
    {"offset": {"line": 664, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getLogs.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getLogs.ts"],"sourcesContent":["import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash, LogTopic } from '../../types/misc.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { DecodeEventLogErrorType } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormatLogErrorType,\n  formatLog,\n} from '../../utils/formatters/log.js'\n\nexport type GetLogsParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = {\n  /** Address or list of addresses from which logs originated */\n  address?: Address | Address[] | undefined\n} & (\n  | {\n      event: abiEvent\n      events?: undefined\n      args?: MaybeExtractEventArgsFromAbi<abiEvents, _eventName> | undefined\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: strict | undefined\n    }\n  | {\n      event?: undefined\n      events: abiEvents\n      args?: undefined\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: strict | undefined\n    }\n  | {\n      event?: undefined\n      events?: undefined\n      args?: undefined\n      strict?: undefined\n    }\n) &\n  (\n    | {\n        /** Block number or tag after which to include logs */\n        fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n        /** Block number or tag before which to include logs */\n        toBlock?: toBlock | BlockNumber | BlockTag | undefined\n        blockHash?: undefined\n      }\n    | {\n        fromBlock?: undefined\n        toBlock?: undefined\n        /** Hash of block to include logs from */\n        blockHash?: Hash | undefined\n      }\n  )\n\nexport type GetLogsReturnType<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _pending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _pending, abiEvent, strict, abiEvents, _eventName>[]\n\nexport type GetLogsErrorType =\n  | DecodeEventLogErrorType\n  | EncodeEventTopicsErrorType\n  | FormatLogErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    events: events_,\n    args,\n    strict: strict_,\n  }: GetLogsParameters<abiEvent, abiEvents, strict, fromBlock, toBlock> = {},\n): Promise<GetLogsReturnType<abiEvent, abiEvents, strict, fromBlock, toBlock>> {\n  const strict = strict_ ?? false\n  const events = events_ ?? (event ? [event] : undefined)\n\n  let topics: LogTopic[] = []\n  if (events) {\n    const encoded = (events as AbiEvent[]).flatMap((event) =>\n      encodeEventTopics({\n        abi: [event],\n        eventName: (event as AbiEvent).name,\n        args: events_ ? undefined : args,\n      } as EncodeEventTopicsParameters),\n    )\n    // TODO: Clean up type casting\n    topics = [encoded as LogTopic]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  let logs: RpcLog[]\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{ address, topics, blockHash }],\n    })\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [\n        {\n          address,\n          topics,\n          fromBlock:\n            typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n          toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        },\n      ],\n    })\n  }\n\n  const formattedLogs = logs.map((log) => formatLog(log))\n  if (!events)\n    return formattedLogs as GetLogsReturnType<\n      abiEvent,\n      abiEvents,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  return parseEventLogs({\n    abi: events,\n    args: args as any,\n    logs: formattedLogs,\n    strict,\n  }) as unknown as GetLogsReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n"],"names":[],"mappings":";;;;AAeA,OAAO,EAGL,iBAAiB,GAClB,MAAM,sCAAsC,CAAA;AAC7C,OAAO,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAA;AAElE,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;AACtC,OAAO,EAEL,SAAS,GACV,MAAM,+BAA+B,CAAA;;;;;AA0G/B,KAAK,UAAU,OAAO,CAW3B,MAAgC,EAChC,EACE,OAAO,EACP,SAAS,EACT,SAAS,EACT,OAAO,EACP,KAAK,EACL,MAAM,EAAE,OAAO,EACf,IAAI,EACJ,MAAM,EAAE,OAAO,EAAA,GACuD,CAAA,CAAE;IAE1E,MAAM,MAAM,GAAG,OAAO,IAAI,KAAK,CAAA;IAC/B,MAAM,MAAM,GAAG,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAAC,KAAK;KAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAA;IAEvD,IAAI,MAAM,GAAe,EAAE,CAAA;IAC3B,IAAI,MAAM,EAAE,CAAC;QACX,MAAM,OAAO,GAAI,MAAqB,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CACrD,CADuD,gBACtC,8KAAC;gBAChB,GAAG,EAAE;oBAAC,KAAK;iBAAC;gBACZ,SAAS,EAAG,KAAkB,CAAC,IAAI;gBACnC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI;aACF,CAAC,CAClC,CAAA;QACD,8BAA8B;QAC9B,MAAM,GAAG;YAAC,OAAmB;SAAC,CAAA;QAC9B,IAAI,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC,CAAC,CAAe,CAAA;IAC7C,CAAC;IAED,IAAI,IAAc,CAAA;IAClB,IAAI,SAAS,EAAE,CAAC;QACd,IAAI,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;YAC1B,MAAM,EAAE,aAAa;YACrB,MAAM,EAAE;gBAAC;oBAAE,OAAO;oBAAE,MAAM;oBAAE,SAAS;gBAAA,CAAE;aAAC;SACzC,CAAC,CAAA;IACJ,CAAC,MAAM,CAAC;QACN,IAAI,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;YAC1B,MAAM,EAAE,aAAa;YACrB,MAAM,EAAE;gBACN;oBACE,OAAO;oBACP,MAAM;oBACN,SAAS,EACP,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS;oBACpE,OAAO,EAAE,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO;iBACtE;aACF;SACF,CAAC,CAAA;IACJ,CAAC;IAED,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAG,CAAD,QAAU,uKAAC,GAAG,CAAC,CAAC,CAAA;IACvD,IAAI,CAAC,MAAM,EACT,OAAO,aAMN,CAAA;IACH,WAAO,mLAAc,EAAC;QACpB,GAAG,EAAE,MAAM;QACX,IAAI,EAAE,IAAW;QACjB,IAAI,EAAE,aAAa;QACnB,MAAM;KACP,CAMA,CAAA;AACH,CAAC","debugId":null}},
    {"offset": {"line": 734, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getContractEvents.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getContractEvents.ts"],"sourcesContent":["import type { Abi, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n} from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash } from '../../types/misc.js'\nimport {\n  type GetAbiItemErrorType,\n  type GetAbiItemParameters,\n  getAbiItem,\n} from '../../utils/abi/getAbiItem.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type GetLogsErrorType,\n  type GetLogsParameters,\n  getLogs,\n} from './getLogs.js'\n\nexport type GetContractEventsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined =\n    | ContractEventName<abi>\n    | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Contract ABI. */\n  abi: abi\n  args?:\n    | ContractEventArgs<\n        abi,\n        eventName extends ContractEventName<abi>\n          ? eventName\n          : ContractEventName<abi>\n      >\n    | undefined\n  /** Contract event. */\n  eventName?: eventName | ContractEventName<abi> | undefined\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: strict | boolean | undefined\n} & (\n  | {\n      /** Block number or tag after which to include logs */\n      fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n      /** Block number or tag before which to include logs */\n      toBlock?: toBlock | BlockNumber | BlockTag | undefined\n      blockHash?: undefined\n    }\n  | {\n      fromBlock?: undefined\n      toBlock?: undefined\n      /** Hash of block to include logs from */\n      blockHash?: Hash | undefined\n    }\n)\n\nexport type GetContractEventsReturnType<\n  abi extends Abi | readonly unknown[] = readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined =\n    | ContractEventName<abi>\n    | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  ///\n  isPending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = Log<bigint, number, isPending, undefined, strict, abi, eventName>[]\n\nexport type GetContractEventsErrorType =\n  | GetAbiItemErrorType\n  | GetLogsErrorType\n  | ErrorType\n\n/**\n * Returns a list of event logs emitted by a contract.\n *\n * - Docs: https://viem.sh/docs/contract/getContractEvents#getcontractevents\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetContractEventsParameters}\n * @returns A list of event logs. {@link GetContractEventsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getContractEvents } from 'viem/public'\n * import { wagmiAbi } from './abi'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getContractEvents(client, {\n *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *  abi: wagmiAbi,\n *  eventName: 'Transfer'\n * })\n */\nexport async function getContractEvents<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: GetContractEventsParameters<\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >,\n): Promise<\n  GetContractEventsReturnType<abi, eventName, strict, fromBlock, toBlock>\n> {\n  const {\n    abi,\n    address,\n    args,\n    blockHash,\n    eventName,\n    fromBlock,\n    toBlock,\n    strict,\n  } = parameters\n  const event = eventName\n    ? getAbiItem({ abi, name: eventName } as GetAbiItemParameters)\n    : undefined\n  const events = !event\n    ? (abi as Abi).filter((x) => x.type === 'event')\n    : undefined\n  return getAction(\n    client,\n    getLogs,\n    'getLogs',\n  )({\n    address,\n    args,\n    blockHash,\n    event,\n    events,\n    fromBlock,\n    toBlock,\n    strict,\n  } as {} as GetLogsParameters) as unknown as GetContractEventsReturnType<\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n"],"names":[],"mappings":";;;;AAaA,OAAO,EAGL,UAAU,GACX,MAAM,+BAA+B,CAAA;AACtC,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAGL,OAAO,GACR,MAAM,cAAc,CAAA;;;;AA2Fd,KAAK,UAAU,iBAAiB,CAQrC,MAAgC,EAChC,UAMC;IAID,MAAM,EACJ,GAAG,EACH,OAAO,EACP,IAAI,EACJ,SAAS,EACT,SAAS,EACT,SAAS,EACT,OAAO,EACP,MAAM,EACP,GAAG,UAAU,CAAA;IACd,MAAM,KAAK,GAAG,SAAS,OACnB,2KAAU,EAAC;QAAE,GAAG;QAAE,IAAI,EAAE,SAAS;IAAA,CAA0B,CAAC,GAC5D,SAAS,CAAA;IACb,MAAM,MAAM,GAAG,CAAC,KAAK,GAChB,GAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,IAAI,KAAK,OAAO,CAAC,GAC9C,SAAS,CAAA;IACb,WAAO,kKAAS,EACd,MAAM,EACN,0KAAO,EACP,SAAS,CACV,CAAC;QACA,OAAO;QACP,IAAI;QACJ,SAAS;QACT,KAAK;QACL,MAAM;QACN,SAAS;QACT,OAAO;QACP,MAAM;KACoB,CAM3B,CAAA;AACH,CAAC","debugId":null}},
    {"offset": {"line": 766, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getEip712Domain.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getEip712Domain.ts"],"sourcesContent":["import type { Address, TypedDataDomain } from 'abitype'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  Eip712DomainNotFoundError,\n  type Eip712DomainNotFoundErrorType,\n} from '../../errors/eip712.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequiredBy } from '../../types/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from './readContract.js'\n\nexport type GetEip712DomainParameters = {\n  address: Address\n} & Pick<ReadContractParameters, 'factory' | 'factoryData'>\n\nexport type GetEip712DomainReturnType = {\n  domain: RequiredBy<\n    TypedDataDomain,\n    'chainId' | 'name' | 'verifyingContract' | 'salt' | 'version'\n  >\n  fields: Hex\n  extensions: readonly bigint[]\n}\n\nexport type GetEip712DomainErrorType =\n  | Eip712DomainNotFoundErrorType\n  | ReadContractErrorType\n  | ErrorType\n\n/**\n * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.\n *\n * @param client - A {@link Client} instance.\n * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}\n * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, getEip712Domain } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const domain = await getEip712Domain(client, {\n *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * })\n * // {\n * //   domain: {\n * //     name: 'ExampleContract',\n * //     version: '1',\n * //     chainId: 1,\n * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * //   },\n * //   fields: '0x0f',\n * //   extensions: [],\n * // }\n * ```\n */\nexport async function getEip712Domain(\n  client: Client<Transport>,\n  parameters: GetEip712DomainParameters,\n): Promise<GetEip712DomainReturnType> {\n  const { address, factory, factoryData } = parameters\n\n  try {\n    const [\n      fields,\n      name,\n      version,\n      chainId,\n      verifyingContract,\n      salt,\n      extensions,\n    ] = await getAction(\n      client,\n      readContract,\n      'readContract',\n    )({\n      abi,\n      address,\n      functionName: 'eip712Domain',\n      factory,\n      factoryData,\n    })\n\n    return {\n      domain: {\n        name,\n        version,\n        chainId: Number(chainId),\n        verifyingContract,\n        salt,\n      },\n      extensions,\n      fields,\n    }\n  } catch (e) {\n    const error = e as ReadContractErrorType\n    if (\n      error.name === 'ContractFunctionExecutionError' &&\n      error.cause.name === 'ContractFunctionZeroDataError'\n    ) {\n      throw new Eip712DomainNotFoundError({ address })\n    }\n    throw error\n  }\n}\n\nconst abi = [\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { name: 'fields', type: 'bytes1' },\n      { name: 'name', type: 'string' },\n      { name: 'version', type: 'string' },\n      { name: 'chainId', type: 'uint256' },\n      { name: 'verifyingContract', type: 'address' },\n      { name: 'salt', type: 'bytes32' },\n      { name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n"],"names":[],"mappings":";;;;AAGA,OAAO,EACL,yBAAyB,GAE1B,MAAM,wBAAwB,CAAA;AAI/B,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAGL,YAAY,GACb,MAAM,mBAAmB,CAAA;;;;AAoDnB,KAAK,UAAU,eAAe,CACnC,MAAyB,EACzB,UAAqC;IAErC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,UAAU,CAAA;IAEpD,IAAI,CAAC;QACH,MAAM,CACJ,MAAM,EACN,IAAI,EACJ,OAAO,EACP,OAAO,EACP,iBAAiB,EACjB,IAAI,EACJ,UAAU,CACX,GAAG,UAAM,kKAAS,EACjB,MAAM,EACN,oLAAY,EACZ,cAAc,CACf,CAAC;YACA,GAAG;YACH,OAAO;YACP,YAAY,EAAE,cAAc;YAC5B,OAAO;YACP,WAAW;SACZ,CAAC,CAAA;QAEF,OAAO;YACL,MAAM,EAAE;gBACN,IAAI;gBACJ,OAAO;gBACP,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC;gBACxB,iBAAiB;gBACjB,IAAI;aACL;YACD,UAAU;YACV,MAAM;SACP,CAAA;IACH,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;QACX,MAAM,KAAK,GAAG,CAA0B,CAAA;QACxC,IACE,KAAK,CAAC,IAAI,KAAK,gCAAgC,IAC/C,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,+BAA+B,EACpD,CAAC;YACD,MAAM,IAAI,gLAAyB,CAAC;gBAAE,OAAO;YAAA,CAAE,CAAC,CAAA;QAClD,CAAC;QACD,MAAM,KAAK,CAAA;IACb,CAAC;AACH,CAAC;AAED,MAAM,GAAG,GAAG;IACV;QACE,MAAM,EAAE,EAAE;QACV,IAAI,EAAE,cAAc;QACpB,OAAO,EAAE;YACP;gBAAE,IAAI,EAAE,QAAQ;gBAAE,IAAI,EAAE,QAAQ;YAAA,CAAE;YAClC;gBAAE,IAAI,EAAE,MAAM;gBAAE,IAAI,EAAE,QAAQ;YAAA,CAAE;YAChC;gBAAE,IAAI,EAAE,SAAS;gBAAE,IAAI,EAAE,QAAQ;YAAA,CAAE;YACnC;gBAAE,IAAI,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;YACpC;gBAAE,IAAI,EAAE,mBAAmB;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;YAC9C;gBAAE,IAAI,EAAE,MAAM;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;YACjC;gBAAE,IAAI,EAAE,YAAY;gBAAE,IAAI,EAAE,WAAW;YAAA,CAAE;SAC1C;QACD,eAAe,EAAE,MAAM;QACvB,IAAI,EAAE,UAAU;KACjB;CACO,CAAA","debugId":null}},
    {"offset": {"line": 849, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getFeeHistory.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getFeeHistory.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { FeeHistory } from '../../types/fee.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormatFeeHistoryErrorType,\n  formatFeeHistory,\n} from '../../utils/formatters/feeHistory.js'\n\nexport type GetFeeHistoryParameters = {\n  /**\n   * Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.\n   */\n  blockCount: number\n  /**\n   * A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.\n   */\n  rewardPercentiles: number[]\n} & (\n  | {\n      blockNumber?: undefined\n      /**\n       * Highest number block of the requested range.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n  | {\n      /** Highest number block of the requested range. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n)\nexport type GetFeeHistoryReturnType = FeeHistory\n\nexport type GetFeeHistoryErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | FormatFeeHistoryErrorType\n\n/**\n * Returns a collection of historical gas information.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFeeHistory\n * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)\n *\n * @param client - Client to use\n * @param parameters - {@link GetFeeHistoryParameters}\n * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getFeeHistory } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const feeHistory = await getFeeHistory(client, {\n *   blockCount: 4,\n *   rewardPercentiles: [25, 75],\n * })\n */\nexport async function getFeeHistory<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockCount,\n    blockNumber,\n    blockTag = 'latest',\n    rewardPercentiles,\n  }: GetFeeHistoryParameters,\n): Promise<GetFeeHistoryReturnType> {\n  const blockNumberHex =\n    typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n  const feeHistory = await client.request(\n    {\n      method: 'eth_feeHistory',\n      params: [\n        numberToHex(blockCount),\n        blockNumberHex || blockTag,\n        rewardPercentiles,\n      ],\n    },\n    { dedupe: Boolean(blockNumberHex) },\n  )\n  return formatFeeHistory(feeHistory)\n}\n"],"names":[],"mappings":";;;;AAMA,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;AACtC,OAAO,EAEL,gBAAgB,GACjB,MAAM,sCAAsC,CAAA;;;AAyDtC,KAAK,UAAU,aAAa,CACjC,MAAgC,EAChC,EACE,UAAU,EACV,WAAW,EACX,QAAQ,GAAG,QAAQ,EACnB,iBAAiB,EACO;IAE1B,MAAM,cAAc,GAClB,OAAO,WAAW,KAAK,QAAQ,CAAC,CAAC,KAAC,4KAAW,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IACxE,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,OAAO,CACrC;QACE,MAAM,EAAE,gBAAgB;QACxB,MAAM,EAAE;gBACN,4KAAW,EAAC,UAAU,CAAC;YACvB,cAAc,IAAI,QAAQ;YAC1B,iBAAiB;SAClB;KACF,EACD;QAAE,MAAM,EAAE,OAAO,CAAC,cAAc,CAAC;IAAA,CAAE,CACpC,CAAA;IACD,WAAO,wLAAgB,EAAC,UAAU,CAAC,CAAA;AACrC,CAAC","debugId":null}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getFilterLogs.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getFilterLogs.ts"],"sourcesContent":["import type { Abi, AbiEvent, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { DecodeEventLogErrorType } from '../../utils/abi/decodeEventLog.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type FormatLogErrorType,\n  formatLog,\n} from '../../utils/formatters/log.js'\n\nexport type GetFilterLogsParameters<\n  abi extends Abi | readonly unknown[] | undefined = undefined,\n  eventName extends string | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  filter: Filter<'event', abi, eventName, any, strict, fromBlock, toBlock>\n}\nexport type GetFilterLogsReturnType<\n  abi extends Abi | readonly unknown[] | undefined = undefined,\n  eventName extends string | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _AbiEvent extends AbiEvent | undefined = abi extends Abi\n    ? eventName extends string\n      ? ExtractAbiEvent<abi, eventName>\n      : undefined\n    : undefined,\n  _Pending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _Pending, _AbiEvent, strict, abi, eventName>[]\n\nexport type GetFilterLogsErrorType =\n  | RequestErrorType\n  | DecodeEventLogErrorType\n  | FormatLogErrorType\n  | ErrorType\n\n/**\n * Returns a list of event logs since the filter was created.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterLogs\n * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n *\n * `getFilterLogs` is only compatible with **event filters**.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterLogsParameters}\n * @returns A list of event logs. {@link GetFilterLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterLogs(client, { filter })\n */\nexport async function getFilterLogs<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[] | undefined,\n  eventName extends string | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  _client: Client<Transport, chain>,\n  {\n    filter,\n  }: GetFilterLogsParameters<abi, eventName, strict, fromBlock, toBlock>,\n): Promise<\n  GetFilterLogsReturnType<abi, eventName, strict, fromBlock, toBlock>\n> {\n  const strict = filter.strict ?? false\n\n  const logs = await filter.request({\n    method: 'eth_getFilterLogs',\n    params: [filter.id],\n  })\n\n  const formattedLogs = logs.map((log) => formatLog(log))\n  if (!filter.abi)\n    return formattedLogs as GetFilterLogsReturnType<\n      abi,\n      eventName,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  return parseEventLogs({\n    abi: filter.abi,\n    logs: formattedLogs,\n    strict,\n  }) as unknown as GetFilterLogsReturnType<\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n"],"names":[],"mappings":";;;;AAWA,OAAO,EAAE,cAAc,EAAE,MAAM,mCAAmC,CAAA;AAElE,OAAO,EAEL,SAAS,GACV,MAAM,+BAA+B,CAAA;;;AA4D/B,KAAK,UAAU,aAAa,CAQjC,OAAiC,EACjC,EACE,MAAM,EAC8D;IAItE,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,KAAK,CAAA;IAErC,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QAChC,MAAM,EAAE,mBAAmB;QAC3B,MAAM,EAAE;YAAC,MAAM,CAAC,EAAE;SAAC;KACpB,CAAC,CAAA;IAEF,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,GAAC,0KAAS,EAAC,GAAG,CAAC,CAAC,CAAA;IACvD,IAAI,CAAC,MAAM,CAAC,GAAG,EACb,OAAO,aAMN,CAAA;IACH,WAAO,mLAAc,EAAC;QACpB,GAAG,EAAE,MAAM,CAAC,GAAG;QACf,IAAI,EAAE,aAAa;QACnB,MAAM;KACP,CAMA,CAAA;AACH,CAAC","debugId":null}},
    {"offset": {"line": 903, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getProof.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getProof.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Proof } from '../../types/proof.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormatProofErrorType,\n  formatProof,\n} from '../../utils/formatters/proof.js'\n\nexport type GetProofParameters = {\n  /** Account address. */\n  address: Address\n  /** Array of storage-keys that should be proofed and included. */\n  storageKeys: Hash[]\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /**\n       * The block tag.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type GetProofReturnType = Proof\n\nexport type GetProofErrorType =\n  | NumberToHexErrorType\n  | FormatProofErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the account and storage values of the specified account including the Merkle-proof.\n *\n * - Docs: https://viem.sh/docs/actions/public/getProof\n * - JSON-RPC Methods:\n *   - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)\n *\n * @param client - Client to use\n * @param parameters - {@link GetProofParameters}\n * @returns Proof data. {@link GetProofReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getProof } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getProof(client, {\n *  address: '0x...',\n *  storageKeys: ['0x...'],\n * })\n */\nexport async function getProof<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    blockNumber,\n    blockTag: blockTag_,\n    storageKeys,\n  }: GetProofParameters,\n): Promise<GetProofReturnType> {\n  const blockTag = blockTag_ ?? 'latest'\n\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  const proof = await client.request({\n    method: 'eth_getProof',\n    params: [address, storageKeys, blockNumberHex || blockTag],\n  })\n\n  return formatProof(proof)\n}\n"],"names":[],"mappings":";;;;AASA,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;AACtC,OAAO,EAEL,WAAW,GACZ,MAAM,iCAAiC,CAAA;;;AAwDjC,KAAK,UAAU,QAAQ,CAC5B,MAAgC,EAChC,EACE,OAAO,EACP,WAAW,EACX,QAAQ,EAAE,SAAS,EACnB,WAAW,EACQ;IAErB,MAAM,QAAQ,GAAG,SAAS,IAAI,QAAQ,CAAA;IAEtC,MAAM,cAAc,GAClB,WAAW,KAAK,SAAS,CAAC,CAAC,KAAC,4KAAW,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IAElE,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QACjC,MAAM,EAAE,cAAc;QACtB,MAAM,EAAE;YAAC,OAAO;YAAE,WAAW;YAAE,cAAc,IAAI,QAAQ;SAAC;KAC3D,CAAC,CAAA;IAEF,WAAO,8KAAW,EAAC,KAAK,CAAC,CAAA;AAC3B,CAAC","debugId":null}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getStorageAt.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getStorageAt.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetStorageAtParameters = {\n  address: Address\n  slot: Hex\n} & (\n  | {\n      blockNumber?: undefined\n      blockTag?: BlockTag | undefined\n    }\n  | {\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n)\n\nexport type GetStorageAtReturnType = Hex | undefined\n\nexport type GetStorageAtErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the value from a storage slot at a given address.\n *\n * - Docs: https://viem.sh/docs/contract/getStorageAt\n * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)\n *\n * @param client - Client to use\n * @param parameters - {@link GetStorageAtParameters}\n * @returns The value of the storage slot. {@link GetStorageAtReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getStorageAt } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getStorageAt(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   slot: toHex(0),\n * })\n */\nexport async function getStorageAt<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { address, blockNumber, blockTag = 'latest', slot }: GetStorageAtParameters,\n): Promise<GetStorageAtReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const data = await client.request({\n    method: 'eth_getStorageAt',\n    params: [address, slot, blockNumberHex || blockTag],\n  })\n  return data\n}\n"],"names":[],"mappings":";;;;AASA,OAAO,EAEL,WAAW,GACZ,MAAM,+BAA+B,CAAA;;AA+C/B,KAAK,UAAU,YAAY,CAChC,MAAgC,EAChC,EAAE,OAAO,EAAE,WAAW,EAAE,QAAQ,GAAG,QAAQ,EAAE,IAAI,EAA0B;IAE3E,MAAM,cAAc,GAClB,WAAW,KAAK,SAAS,CAAC,CAAC,KAAC,4KAAW,EAAC,WAAW,CAAC,CAAC,CAAC,CAAC,SAAS,CAAA;IAClE,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC;QAChC,MAAM,EAAE,kBAAkB;QAC1B,MAAM,EAAE;YAAC,OAAO;YAAE,IAAI;YAAE,cAAc,IAAI,QAAQ;SAAC;KACpD,CAAC,CAAA;IACF,OAAO,IAAI,CAAA;AACb,CAAC","debugId":null}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/getTransactionConfirmations.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/getTransactionConfirmations.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { FormattedTransactionReceipt } from '../../utils/formatters/transactionReceipt.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport {\n  type GetBlockNumberErrorType,\n  getBlockNumber,\n} from './getBlockNumber.js'\nimport {\n  type GetTransactionErrorType,\n  getTransaction,\n} from './getTransaction.js'\n\nexport type GetTransactionConfirmationsParameters<\n  chain extends Chain | undefined = Chain,\n> =\n  | {\n      /** The transaction hash. */\n      hash: Hash\n      transactionReceipt?: undefined\n    }\n  | {\n      hash?: undefined\n      /** The transaction receipt. */\n      transactionReceipt: FormattedTransactionReceipt<chain>\n    }\n\nexport type GetTransactionConfirmationsReturnType = bigint\n\nexport type GetTransactionConfirmationsErrorType =\n  | GetBlockNumberErrorType\n  | GetTransactionErrorType\n  | ErrorType\n\n/**\n * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionConfirmationsParameters}\n * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionConfirmations } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const confirmations = await getTransactionConfirmations(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionConfirmations<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  { hash, transactionReceipt }: GetTransactionConfirmationsParameters<chain>,\n): Promise<GetTransactionConfirmationsReturnType> {\n  const [blockNumber, transaction] = await Promise.all([\n    getAction(client, getBlockNumber, 'getBlockNumber')({}),\n    hash\n      ? getAction(client, getTransaction, 'getTransaction')({ hash })\n      : undefined,\n  ])\n  const transactionBlockNumber =\n    transactionReceipt?.blockNumber || transaction?.blockNumber\n  if (!transactionBlockNumber) return 0n\n  return blockNumber - transactionBlockNumber! + 1n\n}\n"],"names":[],"mappings":";;;;AAMA,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AAEpD,OAAO,EAEL,cAAc,GACf,MAAM,qBAAqB,CAAA;AAC5B,OAAO,EAEL,cAAc,GACf,MAAM,qBAAqB,CAAA;;;;AA+CrB,KAAK,UAAU,2BAA2B,CAG/C,MAAgC,EAChC,EAAE,IAAI,EAAE,kBAAkB,EAAgD;IAE1E,MAAM,CAAC,WAAW,EAAE,WAAW,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;YACnD,kKAAS,EAAC,MAAM,EAAE,wLAAc,EAAE,gBAAgB,CAAC,CAAC,CAAA,CAAE,CAAC;QACvD,IAAI,OACA,kKAAS,EAAC,MAAM,EAAE,wLAAc,EAAE,gBAAgB,CAAC,CAAC;YAAE,IAAI;QAAA,CAAE,CAAC,GAC7D,SAAS;KACd,CAAC,CAAA;IACF,MAAM,sBAAsB,GAC1B,kBAAkB,EAAE,WAAW,IAAI,WAAW,EAAE,WAAW,CAAA;IAC7D,IAAI,CAAC,sBAAsB,EAAE,OAAO,EAAE,CAAA;IACtC,OAAO,WAAW,GAAG,sBAAuB,GAAG,EAAE,CAAA;AACnD,CAAC","debugId":null}},
    {"offset": {"line": 975, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/simulateBlocks.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/simulateBlocks.ts"],"sourcesContent":["import type { Abi, AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as BlockOverrides from 'ox/BlockOverrides'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { concat } from '../../utils/data/concat.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\nimport {\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from '../../utils/errors/getNodeError.js'\nimport {\n  type FormatBlockErrorType,\n  formatBlock,\n} from '../../utils/formatters/block.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type SerializeStateOverrideErrorType,\n  serializeStateOverride,\n} from '../../utils/stateOverride.js'\nimport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\n\ntype CallExtraProperties = ExactPartial<\n  UnionOmit<\n    TransactionRequest,\n    'blobs' | 'data' | 'kzg' | 'to' | 'sidecars' | 'value'\n  >\n> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n  /** Recipient. `null` if contract deployment. */\n  to?: Address | null | undefined\n}\n\nexport type SimulateBlocksParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Blocks to simulate. */\n  blocks: readonly {\n    /** Block overrides. */\n    blockOverrides?: BlockOverrides.BlockOverrides | undefined\n    /** Calls to execute. */\n    calls: Calls<Narrow<calls>, CallExtraProperties>\n    /** State overrides. */\n    stateOverrides?: StateOverride | undefined\n  }[]\n  /** Whether to return the full transactions. */\n  returnFullTransactions?: boolean | undefined\n  /** Whether to trace transfers. */\n  traceTransfers?: boolean | undefined\n  /** Whether to enable validation mode. */\n  validation?: boolean | undefined\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /**\n       * The balance of the account at a block tag.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type SimulateBlocksReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = readonly (Block & {\n  calls: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n})[]\n\nexport type SimulateBlocksErrorType =\n  | AssertRequestErrorType\n  | DecodeFunctionResultErrorType\n  | EncodeFunctionDataErrorType\n  | FormatBlockErrorType\n  | FormatTransactionRequestErrorType\n  | GetNodeErrorReturnType\n  | ParseAccountErrorType\n  | SerializeStateOverrideErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Simulates a set of calls on block(s) with optional block and state overrides.\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { simulate } from 'viem/actions'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulate(client, {\n *   blocks: [{\n *     blockOverrides: {\n *       number: 69420n,\n *     },\n *     calls: [{\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         data: '0xdeadbeef',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       },\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         value: parseEther('1'),\n *       },\n *     }],\n *     stateOverrides: [{\n *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *       balance: parseEther('10'),\n *     }],\n *   }]\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SimulateBlocksParameters}\n * @returns Simulated blocks. {@link SimulateBlocksReturnType}\n */\nexport async function simulateBlocks<\n  chain extends Chain | undefined,\n  const calls extends readonly unknown[],\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateBlocksParameters<calls>,\n): Promise<SimulateBlocksReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag = client.experimental_blockTag ?? 'latest',\n    blocks,\n    returnFullTransactions,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  try {\n    const blockStateCalls = []\n    for (const block of blocks) {\n      const blockOverrides = block.blockOverrides\n        ? BlockOverrides.toRpc(block.blockOverrides)\n        : undefined\n      const calls = block.calls.map((call_) => {\n        const call = call_ as Call<unknown, CallExtraProperties>\n        const account = call.account ? parseAccount(call.account) : undefined\n        const data = call.abi ? encodeFunctionData(call) : call.data\n        const request = {\n          ...call,\n          account,\n          data: call.dataSuffix\n            ? concat([data || '0x', call.dataSuffix])\n            : data,\n          from: call.from ?? account?.address,\n        } as const\n        assertRequest(request)\n        return formatTransactionRequest(request)\n      })\n      const stateOverrides = block.stateOverrides\n        ? serializeStateOverride(block.stateOverrides)\n        : undefined\n\n      blockStateCalls.push({\n        blockOverrides,\n        calls,\n        stateOverrides,\n      })\n    }\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const result = await client.request({\n      method: 'eth_simulateV1',\n      params: [\n        { blockStateCalls, returnFullTransactions, traceTransfers, validation },\n        block,\n      ],\n    })\n\n    return result.map((block, i) => ({\n      ...formatBlock(block),\n      calls: block.calls.map((call, j) => {\n        const { abi, args, functionName, to } = blocks[i].calls[j] as Call<\n          unknown,\n          CallExtraProperties\n        >\n\n        const data = call.error?.data ?? call.returnData\n        const gasUsed = BigInt(call.gasUsed)\n        const logs = call.logs?.map((log) => formatLog(log))\n        const status = call.status === '0x1' ? 'success' : 'failure'\n\n        const result =\n          abi && status === 'success' && data !== '0x'\n            ? decodeFunctionResult({\n                abi,\n                data,\n                functionName,\n              })\n            : null\n\n        const error = (() => {\n          if (status === 'success') return undefined\n\n          let error: Error | undefined\n          if (call.error?.data === '0x') error = new AbiDecodingZeroDataError()\n          else if (call.error) error = new RawContractError(call.error)\n\n          if (!error) return undefined\n          return getContractError(error, {\n            abi: (abi ?? []) as Abi,\n            address: to ?? '0x',\n            args,\n            functionName: functionName ?? '<unknown>',\n          })\n        })()\n\n        return {\n          data,\n          gasUsed,\n          logs,\n          status,\n          ...(status === 'success'\n            ? {\n                result,\n              }\n            : {\n                error,\n              }),\n        }\n      }),\n    })) as unknown as SimulateBlocksReturnType<calls>\n  } catch (e) {\n    const cause = e as BaseError\n    const error = getNodeError(cause, {})\n    if (error instanceof UnknownNodeError) throw cause\n    throw error\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1104, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/simulateCalls.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/simulateCalls.ts"],"sourcesContent":["import type { AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as AbiConstructor from 'ox/AbiConstructor'\nimport * as AbiFunction from 'ox/AbiFunction'\n\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { ethAddress, zeroAddress } from '../../constants/address.js'\nimport { deploylessCallViaBytecodeBytecode } from '../../constants/contracts.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { Mutable } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { hexToBigInt } from '../../utils/index.js'\nimport {\n  type CreateAccessListErrorType,\n  createAccessList,\n} from './createAccessList.js'\nimport {\n  type SimulateBlocksErrorType,\n  type SimulateBlocksParameters,\n  simulateBlocks,\n} from './simulateBlocks.js'\n\nconst getBalanceCode =\n  '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033'\n\nexport type SimulateCallsParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n  account extends Account | Address | undefined = Account | Address | undefined,\n> = Omit<SimulateBlocksParameters, 'blocks' | 'returnFullTransactions'> & {\n  /** Account attached to the calls (msg.sender). */\n  account?: account | undefined\n  /** Calls to simulate. */\n  calls: Calls<Narrow<calls>>\n  /** State overrides. */\n  stateOverrides?: StateOverride | undefined\n  /** Whether to trace asset changes. */\n  traceAssetChanges?: boolean | undefined\n}\n\nexport type SimulateCallsReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Asset changes. */\n  assetChanges: readonly {\n    token: {\n      address: Address\n      decimals?: number | undefined\n      symbol?: string | undefined\n    }\n    value: { pre: bigint; post: bigint; diff: bigint }\n  }[]\n  /** Block results. */\n  block: Block\n  /** Call results. */\n  results: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n}\n\nexport type SimulateCallsErrorType =\n  | AbiFunction.encodeData.ErrorType\n  | AbiFunction.from.ErrorType\n  | CreateAccessListErrorType\n  | EncodeFunctionDataErrorType\n  | SimulateBlocksErrorType\n  | ErrorType\n\n/**\n * Simulates execution of a batch of calls.\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateCallsParameters}\n * @returns Results. {@link SimulateCallsReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateCalls } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulateCalls(client, {\n *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *   calls: [{\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: parseEther('1'),\n *     },\n *   ]\n * })\n * ```\n */\nexport async function simulateCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateCallsParameters<calls, account>,\n): Promise<SimulateCallsReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag,\n    calls,\n    stateOverrides,\n    traceAssetChanges,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  const account = parameters.account\n    ? parseAccount(parameters.account)\n    : undefined\n\n  if (traceAssetChanges && !account)\n    throw new BaseError(\n      '`account` is required when `traceAssetChanges` is true',\n    )\n\n  // Derive bytecode to extract ETH balance via a contract call.\n  const getBalanceData = account\n    ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n        bytecode: deploylessCallViaBytecodeBytecode,\n        args: [\n          getBalanceCode,\n          AbiFunction.encodeData(\n            AbiFunction.from('function getBalance(address)'),\n            [account.address],\n          ),\n        ],\n      })\n    : undefined\n\n  // Fetch ERC20/721 addresses that were \"touched\" from the calls.\n  const assetAddresses = traceAssetChanges\n    ? await Promise.all(\n        parameters.calls.map(async (call: any) => {\n          if (!call.data && !call.abi) return\n          const { accessList } = await createAccessList(client, {\n            account: account!.address,\n            ...call,\n            data: call.abi ? encodeFunctionData(call) : call.data,\n          })\n          return accessList.map(({ address, storageKeys }) =>\n            storageKeys.length > 0 ? address : null,\n          )\n        }),\n      ).then((x) => x.flat().filter(Boolean))\n    : []\n\n  const blocks = await simulateBlocks(client, {\n    blockNumber,\n    blockTag: blockTag as undefined,\n    blocks: [\n      ...(traceAssetChanges\n        ? [\n            // ETH pre balances\n            {\n              calls: [{ data: getBalanceData }],\n              stateOverrides,\n            },\n\n            // Asset pre balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n\n      {\n        calls: [...calls, {}].map((call) => ({\n          ...(call as Call),\n          from: account?.address,\n        })) as any,\n        stateOverrides,\n      },\n\n      ...(traceAssetChanges\n        ? [\n            // ETH post balances\n            {\n              calls: [{ data: getBalanceData }],\n            },\n\n            // Asset post balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Decimals\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from('function decimals() returns (uint256)'),\n                ],\n                functionName: 'decimals',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Token URI\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from(\n                    'function tokenURI(uint256) returns (string)',\n                  ),\n                ],\n                functionName: 'tokenURI',\n                args: [0n],\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Symbols\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [AbiFunction.from('function symbol() returns (string)')],\n                functionName: 'symbol',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n    ],\n    traceTransfers,\n    validation,\n  })\n\n  const block_results = traceAssetChanges ? blocks[2] : blocks[0]\n  const [\n    block_ethPre,\n    block_assetsPre,\n    ,\n    block_ethPost,\n    block_assetsPost,\n    block_decimals,\n    block_tokenURI,\n    block_symbols,\n  ] = traceAssetChanges ? blocks : []\n\n  // Extract call results from the simulation.\n  const { calls: block_calls, ...block } = block_results\n  const results = block_calls.slice(0, -1) ?? []\n\n  // Extract pre-execution ETH and asset balances.\n  const ethPre = block_ethPre?.calls ?? []\n  const assetsPre = block_assetsPre?.calls ?? []\n  const balancesPre = [...ethPre, ...assetsPre].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract post-execution ETH and asset balances.\n  const ethPost = block_ethPost?.calls ?? []\n  const assetsPost = block_assetsPost?.calls ?? []\n  const balancesPost = [...ethPost, ...assetsPost].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract asset symbols & decimals.\n  const decimals = (block_decimals?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (number | null)[]\n  const symbols = (block_symbols?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n  const tokenURI = (block_tokenURI?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n\n  const changes: Mutable<SimulateCallsReturnType<calls>['assetChanges']> = []\n  for (const [i, balancePost] of balancesPost.entries()) {\n    const balancePre = balancesPre[i]\n\n    if (typeof balancePost !== 'bigint') continue\n    if (typeof balancePre !== 'bigint') continue\n\n    const decimals_ = decimals[i - 1]\n    const symbol_ = symbols[i - 1]\n    const tokenURI_ = tokenURI[i - 1]\n\n    const token = (() => {\n      if (i === 0)\n        return {\n          address: ethAddress,\n          decimals: 18,\n          symbol: 'ETH',\n        }\n\n      return {\n        address: assetAddresses[i - 1]! as Address,\n        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n        symbol: symbol_ ?? undefined,\n      }\n    })()\n\n    if (changes.some((change) => change.token.address === token.address))\n      continue\n\n    changes.push({\n      token,\n      value: {\n        pre: balancePre,\n        post: balancePost,\n        diff: balancePost - balancePre,\n      },\n    })\n  }\n\n  return {\n    assetChanges: changes,\n    block,\n    results,\n  } as unknown as SimulateCallsReturnType<calls>\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1354, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/simulateContract.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/simulateContract.ts"],"sourcesContent":["import type { Abi, AbiFunction, AbiStateMutability, Address } from 'abitype'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, ParseAccount } from '../../types/account.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n  ExtractAbiFunctionForArgs,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type {\n  IsNarrowable,\n  NoInfer,\n  Prettify,\n  UnionEvaluate,\n  UnionOmit,\n} from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { WriteContractParameters } from '../wallet/writeContract.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type GetMutabilityAwareValue<\n  abi extends Abi | readonly unknown[],\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n  valueType = TransactionRequest['value'],\n  args extends ContractFunctionArgs<\n    abi,\n    mutability,\n    functionName\n  > = ContractFunctionArgs<abi, mutability, functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunctionForArgs<abi, mutability, functionName, args>\n    : AbiFunction,\n  _Narrowable extends boolean = IsNarrowable<abi, Abi>,\n> = _Narrowable extends true\n  ? abiFunction['stateMutability'] extends 'payable'\n    ? { value?: NoInfer<valueType> | undefined }\n    : abiFunction['payable'] extends true\n      ? { value?: NoInfer<valueType> | undefined }\n      : { value?: undefined }\n  : { value?: NoInfer<valueType> | undefined }\n\nexport type SimulateContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n  ///\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  account?: accountOverride | null | undefined\n  chain?: chainOverride | undefined\n  /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n  dataSuffix?: Hex | undefined\n} & ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    CallParameters<derivedChain>,\n    | 'account'\n    | 'batch'\n    | 'code'\n    | 'to'\n    | 'data'\n    | 'factory'\n    | 'factoryData'\n    | 'value'\n  > &\n  GetMutabilityAwareValue<\n    abi,\n    'nonpayable' | 'payable',\n    functionName,\n    CallParameters<derivedChain> extends CallParameters\n      ? CallParameters<derivedChain>['value']\n      : CallParameters['value'],\n    args\n  >\n\nexport type SimulateContractReturnType<\n  out abi extends Abi | readonly unknown[] = Abi,\n  in out functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  in out args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  /** @ts-expect-error cast variance */\n  out chain extends Chain | undefined = Chain | undefined,\n  out account extends Account | undefined = Account | undefined,\n  out chainOverride extends Chain | undefined = Chain | undefined,\n  out accountOverride extends Account | Address | null | undefined =\n    | Account\n    | Address\n    | null\n    | undefined,\n  ///\n  in out minimizedAbi extends Abi = readonly [\n    ExtractAbiFunctionForArgs<\n      abi extends Abi ? abi : Abi,\n      'nonpayable' | 'payable',\n      functionName,\n      args\n    >,\n  ],\n  out resolvedAccount extends\n    | Account\n    | null\n    | undefined = accountOverride extends Account | Address | null\n    ? ParseAccount<accountOverride>\n    : account,\n> = {\n  result: ContractFunctionReturnType<\n    minimizedAbi,\n    'nonpayable' | 'payable',\n    functionName,\n    args\n  >\n  request: Prettify<\n    UnionEvaluate<\n      UnionOmit<\n        WriteContractParameters<\n          minimizedAbi,\n          functionName,\n          args,\n          chain,\n          undefined,\n          chainOverride\n        >,\n        'account' | 'abi' | 'args' | 'chain' | 'functionName'\n      >\n    > &\n      ContractFunctionParameters<\n        minimizedAbi,\n        'nonpayable' | 'payable',\n        functionName,\n        args\n      > & {\n        chain: DeriveChain<chain, chainOverride>\n      } & (resolvedAccount extends Account | null\n        ? { account: resolvedAccount }\n        : { account?: undefined })\n  >\n}\n\nexport type SimulateContractErrorType =\n  | ParseAccountErrorType\n  | EncodeFunctionDataErrorType\n  | GetContractErrorReturnType<CallErrorType | DecodeFunctionResultErrorType>\n  | ErrorType\n\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SimulateContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<\n  SimulateContractReturnType<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >\n> {\n  const { abi, address, args, dataSuffix, functionName, ...callRequest } =\n    parameters as SimulateContractParameters\n\n  const account = callRequest.account\n    ? parseAccount(callRequest.account)\n    : client.account\n  const calldata = encodeFunctionData({ abi, args, functionName })\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      batch: false,\n      data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...callRequest,\n      account,\n    })\n    const result = decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    })\n    const minimizedAbi = abi.filter(\n      (abiItem) =>\n        'name' in abiItem && abiItem.name === parameters.functionName,\n    )\n    return {\n      result,\n      request: {\n        abi: minimizedAbi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...callRequest,\n        account,\n      },\n    } as unknown as SimulateContractReturnType<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAuB7C,OAAO,EAEL,oBAAoB,GACrB,MAAM,yCAAyC,CAAA;AAChD,OAAO,EAEL,kBAAkB,GACnB,MAAM,uCAAuC,CAAA;AAC9C,OAAO,EAEL,gBAAgB,GACjB,MAAM,wCAAwC,CAAA;AAC/C,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AAEpD,OAAO,EAA2C,IAAI,EAAE,MAAM,WAAW,CAAA;;;;;;;AAqLlE,KAAK,UAAU,gBAAgB,CAapC,MAAyC,EACzC,UAOC;IAYD,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE,YAAY,EAAE,GAAG,WAAW,EAAE,GACpE,UAAwC,CAAA;IAE1C,MAAM,OAAO,GAAG,WAAW,CAAC,OAAO,OAC/B,oLAAY,EAAC,WAAW,CAAC,OAAO,CAAC,GACjC,MAAM,CAAC,OAAO,CAAA;IAClB,MAAM,QAAQ,OAAG,2LAAkB,EAAC;QAAE,GAAG;QAAE,IAAI;QAAE,YAAY;IAAA,CAAE,CAAC,CAAA;IAChE,IAAI,CAAC;QACH,MAAM,EAAE,IAAI,EAAE,GAAG,UAAM,kKAAS,EAC9B,MAAM,EACN,oKAAI,EACJ,MAAM,CACP,CAAC;YACA,KAAK,EAAE,KAAK;YACZ,IAAI,EAAE,GAAG,QAAQ,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE;YACpE,EAAE,EAAE,OAAO;YACX,GAAG,WAAW;YACd,OAAO;SACR,CAAC,CAAA;QACF,MAAM,MAAM,OAAG,+LAAoB,EAAC;YAClC,GAAG;YACH,IAAI;YACJ,YAAY;YACZ,IAAI,EAAE,IAAI,IAAI,IAAI;SACnB,CAAC,CAAA;QACF,MAAM,YAAY,GAAG,GAAG,CAAC,MAAM,CAC7B,CAAC,OAAO,EAAE,CACR,CADU,KACJ,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,KAAK,UAAU,CAAC,YAAY,CAChE,CAAA;QACD,OAAO;YACL,MAAM;YACN,OAAO,EAAE;gBACP,GAAG,EAAE,YAAY;gBACjB,OAAO;gBACP,IAAI;gBACJ,UAAU;gBACV,YAAY;gBACZ,GAAG,WAAW;gBACd,OAAO;aACR;SASF,CAAA;IACH,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;QACf,UAAM,0LAAgB,EAAC,KAAkB,EAAE;YACzC,GAAG;YACH,OAAO;YACP,IAAI;YACJ,QAAQ,EAAE,iCAAiC;YAC3C,YAAY;YACZ,MAAM,EAAE,OAAO,EAAE,OAAO;SACzB,CAAC,CAAA;IACJ,CAAC;AACH,CAAC","debugId":null}},
    {"offset": {"line": 1420, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/verifyHash.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/verifyHash.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport { SignatureErc6492 } from 'ox/erc6492'\nimport { SignatureErc8010 } from 'ox/erc8010'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  erc1271Abi,\n  erc6492SignatureValidatorAbi,\n  multicall3Abi,\n} from '../../constants/abis.js'\nimport {\n  erc6492SignatureValidatorByteCode,\n  multicall3Bytecode,\n} from '../../constants/contracts.js'\nimport {\n  CallExecutionError,\n  ContractFunctionExecutionError,\n} from '../../errors/contract.js'\nimport type { InvalidHexBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetAddressErrorType,\n  getAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../../utils/address/isAddressEqual.js'\nimport { verifyAuthorization } from '../../utils/authorization/verifyAuthorization.js'\nimport { type ConcatHexErrorType, concatHex } from '../../utils/data/concat.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { hexToBool } from '../../utils/encoding/fromHex.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from '../../utils/signature/recoverAddress.js'\nimport {\n  type SerializeSignatureErrorType,\n  serializeSignature,\n} from '../../utils/signature/serializeSignature.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\nimport { type GetCodeErrorType, getCode } from './getCode.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The address of the ERC-6492 signature verifier contract. */\n  erc6492VerifierAddress?: Address | undefined\n  /** The hash to be verified. */\n  hash: Hex\n  /** Multicall3 address for ERC-8010 verification. */\n  multicallAddress?: Address | undefined\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n  /** @deprecated use `erc6492VerifierAddress` instead. */\n  universalSignatureVerifierAddress?: Address | undefined\n} & OneOf<{ factory: Address; factoryData: Hex } | {}>\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | BytesToHexErrorType\n  | CallErrorType\n  | ConcatHexErrorType\n  | EncodeDeployDataErrorType\n  | EncodeFunctionDataErrorType\n  | ErrorType\n  | GetAddressErrorType\n  | GetCodeErrorType\n  | InvalidHexBooleanError\n  | IsAddressEqualErrorType\n  | IsHexErrorType\n  | NumberToHexErrorType\n  | ReadContractErrorType\n  | RecoverAddressErrorType\n  | SerializeSignatureErrorType\n\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const {\n    address,\n    hash,\n    erc6492VerifierAddress:\n      verifierAddress = parameters.universalSignatureVerifierAddress ??\n      client.chain?.contracts?.erc6492Verifier?.address,\n    multicallAddress = parameters.multicallAddress ??\n      client.chain?.contracts?.multicall3?.address,\n  } = parameters\n\n  const signature = (() => {\n    const signature = parameters.signature\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  try {\n    if (SignatureErc8010.validate(signature))\n      return await verifyErc8010(client, {\n        ...parameters,\n        multicallAddress,\n        signature,\n      })\n    return await verifyErc6492(client, {\n      ...parameters,\n      verifierAddress,\n      signature,\n    })\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(\n        getAddress(address),\n        await recoverAddress({ hash, signature }),\n      )\n      if (verified) return true\n    } catch {}\n\n    if (error instanceof VerificationError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n\n/** @internal */\nexport async function verifyErc8010(\n  client: Client,\n  parameters: verifyErc8010.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, multicallAddress } = parameters\n\n  const {\n    authorization: authorization_ox,\n    data: initData,\n    signature,\n    to,\n  } = SignatureErc8010.unwrap(parameters.signature)\n\n  // Check if already delegated\n  const code = await getCode(client, {\n    address,\n    blockNumber,\n    blockTag,\n  } as never)\n\n  // If already delegated, perform standard ERC-1271 verification.\n  if (code === concatHex(['0xef0100', authorization_ox.address]))\n    return await verifyErc1271(client, {\n      address,\n      blockNumber,\n      blockTag,\n      hash,\n      signature,\n    })\n\n  const authorization = {\n    address: authorization_ox.address,\n    chainId: Number(authorization_ox.chainId),\n    nonce: Number(authorization_ox.nonce),\n    r: numberToHex(authorization_ox.r, { size: 32 }),\n    s: numberToHex(authorization_ox.s, { size: 32 }),\n    yParity: authorization_ox.yParity,\n  } as const\n\n  const valid = await verifyAuthorization({\n    address,\n    authorization,\n  })\n  if (!valid) throw new VerificationError()\n\n  // Deployless verification.\n  const results = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    ...(multicallAddress\n      ? { address: multicallAddress }\n      : { code: multicall3Bytecode }),\n    authorizationList: [authorization],\n    abi: multicall3Abi,\n    blockNumber,\n    blockTag: 'pending',\n    functionName: 'aggregate3',\n    args: [\n      [\n        ...(initData\n          ? [\n              {\n                allowFailure: true,\n                target: to ?? address,\n                callData: initData,\n              },\n            ]\n          : []),\n        {\n          allowFailure: true,\n          target: address,\n          callData: encodeFunctionData({\n            abi: erc1271Abi,\n            functionName: 'isValidSignature',\n            args: [hash, signature],\n          }),\n        },\n      ],\n    ],\n  })\n\n  const data = results[results.length - 1]?.returnData\n\n  if (data?.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc8010 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** Multicall3 address for ERC-8010 verification. */\n    multicallAddress?: Address | undefined\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nasync function verifyErc6492(\n  client: Client,\n  parameters: verifyErc6492.Parameters,\n) {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    verifierAddress,\n    ...rest\n  } = parameters\n\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signature\n\n    // If the signature is already wrapped, return the signature.\n    if (SignatureErc6492.validate(signature)) return signature\n\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return SignatureErc6492.wrap({\n      data: factoryData!,\n      signature,\n      to: factory!,\n    })\n  })()\n\n  const args = verifierAddress\n    ? ({\n        to: verifierAddress,\n        data: encodeFunctionData({\n          abi: erc6492SignatureValidatorAbi,\n          functionName: 'isValidSig',\n          args: [address, hash, wrappedSignature],\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n    : ({\n        data: encodeDeployData({\n          abi: erc6492SignatureValidatorAbi,\n          args: [address, hash, wrappedSignature],\n          bytecode: erc6492SignatureValidatorByteCode,\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n\n  const { data } = await getAction(\n    client,\n    call,\n    'call',\n  )(args).catch((error) => {\n    if (error instanceof CallExecutionError) throw new VerificationError()\n    throw error\n  })\n\n  if (hexToBool(data ?? '0x0')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc6492 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n    /** The address of the ERC-6492 signature verifier contract. */\n    verifierAddress?: Address | undefined\n  } & OneOf<{ factory: Address; factoryData: Hex } | {}>\n}\n\n/** @internal */\nexport async function verifyErc1271(\n  client: Client,\n  parameters: verifyErc1271.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, signature } = parameters\n\n  const result = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address,\n    abi: erc1271Abi,\n    args: [hash, signature],\n    blockNumber,\n    blockTag,\n    functionName: 'isValidSignature',\n  }).catch((error) => {\n    if (error instanceof ContractFunctionExecutionError)\n      throw new VerificationError()\n    throw error\n  })\n\n  if (result.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc1271 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\nclass VerificationError extends Error {}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1657, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/verifyMessage.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/verifyMessage.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ByteArray,\n  Hex,\n  SignableMessage,\n  Signature,\n} from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { HashMessageErrorType } from '../../utils/signature/hashMessage.js'\nimport { hashMessage } from '../../utils/signature/hashMessage.js'\nimport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  verifyHash,\n} from './verifyHash.js'\n\nexport type VerifyMessageParameters = Prettify<\n  Omit<VerifyHashParameters, 'hash'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The message to be verified. */\n    message: SignableMessage\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex | ByteArray | Signature\n  }\n>\n\nexport type VerifyMessageReturnType = boolean\n\nexport type VerifyMessageErrorType =\n  | HashMessageErrorType\n  | VerifyHashErrorType\n  | ErrorType\n\n/**\n * Verify that a message was signed by the provided address.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nexport async function verifyMessage<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    message,\n    factory,\n    factoryData,\n    signature,\n    ...callRequest\n  }: VerifyMessageParameters,\n): Promise<VerifyMessageReturnType> {\n  const hash = hashMessage(message)\n  return verifyHash(client, {\n    address,\n    factory: factory!,\n    factoryData: factoryData!,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n"],"names":[],"mappings":";;;;AAcA,OAAO,EAAE,WAAW,EAAE,MAAM,sCAAsC,CAAA;AAClE,OAAO,EAGL,UAAU,GACX,MAAM,iBAAiB,CAAA;;;AA+BjB,KAAK,UAAU,aAAa,CACjC,MAAgC,EAChC,EACE,OAAO,EACP,OAAO,EACP,OAAO,EACP,WAAW,EACX,SAAS,EACT,GAAG,WAAW,EACU;IAE1B,MAAM,IAAI,OAAG,mLAAW,EAAC,OAAO,CAAC,CAAA;IACjC,WAAO,gLAAU,EAAC,MAAM,EAAE;QACxB,OAAO;QACP,OAAO,EAAE,OAAQ;QACjB,WAAW,EAAE,WAAY;QACzB,IAAI;QACJ,SAAS;QACT,GAAG,WAAW;KACf,CAAC,CAAA;AACJ,CAAC","debugId":null}},
    {"offset": {"line": 1680, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/verifyTypedData.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/verifyTypedData.ts"],"sourcesContent":["import type { Address, TypedData } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type HashTypedDataErrorType,\n  hashTypedData,\n} from '../../utils/signature/hashTypedData.js'\nimport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  verifyHash,\n} from './verifyHash.js'\n\nexport type VerifyTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = Omit<VerifyHashParameters, 'hash'> &\n  TypedDataDefinition<typedData, primaryType> & {\n    /** The address to verify the typed data for. */\n    address: Address\n    /** The signature to verify */\n    signature: Hex | ByteArray | Signature\n  }\n\nexport type VerifyTypedDataReturnType = boolean\n\nexport type VerifyTypedDataErrorType =\n  | HashTypedDataErrorType\n  | VerifyHashErrorType\n  | ErrorType\n\n/**\n * Verify that typed data was signed by the provided address.\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: VerifyTypedDataParameters<typedData, primaryType>,\n): Promise<VerifyTypedDataReturnType> {\n  const {\n    address,\n    factory,\n    factoryData,\n    signature,\n    message,\n    primaryType,\n    types,\n    domain,\n    ...callRequest\n  } = parameters as VerifyTypedDataParameters\n  const hash = hashTypedData({ message, primaryType, types, domain })\n  return verifyHash(client, {\n    address,\n    factory: factory!,\n    factoryData: factoryData!,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n"],"names":[],"mappings":";;;;AAQA,OAAO,EAEL,aAAa,GACd,MAAM,wCAAwC,CAAA;AAC/C,OAAO,EAGL,UAAU,GACX,MAAM,iBAAiB,CAAA;;;AA6BjB,KAAK,UAAU,eAAe,CAKnC,MAAgC,EAChC,UAA6D;IAE7D,MAAM,EACJ,OAAO,EACP,OAAO,EACP,WAAW,EACX,SAAS,EACT,OAAO,EACP,WAAW,EACX,KAAK,EACL,MAAM,EACN,GAAG,WAAW,EACf,GAAG,UAAuC,CAAA;IAC3C,MAAM,IAAI,OAAG,uLAAa,EAAC;QAAE,OAAO;QAAE,WAAW;QAAE,KAAK;QAAE,MAAM;IAAA,CAAE,CAAC,CAAA;IACnE,WAAO,gLAAU,EAAC,MAAM,EAAE;QACxB,OAAO;QACP,OAAO,EAAE,OAAQ;QACjB,WAAW,EAAE,WAAY;QACzB,IAAI;QACJ,SAAS;QACT,GAAG,WAAW;KACf,CAAC,CAAA;AACJ,CAAC","debugId":null}},
    {"offset": {"line": 1709, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/watchBlocks.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/watchBlocks.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { HasTransportType } from '../../types/transport.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockReturnType, getBlock } from './getBlock.js'\n\nexport type OnBlockParameter<\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = GetBlockReturnType<chain, includeTransactions, blockTag>\n\nexport type OnBlock<\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = (\n  block: OnBlockParameter<chain, includeTransactions, blockTag>,\n  prevBlock: OnBlockParameter<chain, includeTransactions, blockTag> | undefined,\n) => void\n\nexport type WatchBlocksParameters<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = {\n  /** The callback to call when a new block is received. */\n  onBlock: OnBlock<chain, includeTransactions, blockTag>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n} & (\n  | (HasTransportType<transport, 'webSocket' | 'ipc'> extends true\n      ? {\n          blockTag?: undefined\n          emitMissed?: undefined\n          emitOnBegin?: undefined\n          includeTransactions?: undefined\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false | undefined\n          pollingInterval?: undefined\n        }\n      : never)\n  | {\n      /** The block tag. Defaults to \"latest\". */\n      blockTag?: blockTag | BlockTag | undefined\n      /** Whether or not to emit the missed blocks to the callback. */\n      emitMissed?: boolean | undefined\n      /** Whether or not to emit the block to the callback when the subscription opens. */\n      emitOnBegin?: boolean | undefined\n      /** Whether or not to include transaction data in the response. */\n      includeTransactions?: includeTransactions | undefined\n      poll?: true | undefined\n      /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */\n      pollingInterval?: number | undefined\n    }\n)\n\nexport type WatchBlocksReturnType = () => void\n\nexport type WatchBlocksErrorType =\n  | StringifyErrorType\n  | PollErrorType\n  | ErrorType\n\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n>(\n  client: Client<transport, chain>,\n  {\n    blockTag = client.experimental_blockTag ?? 'latest',\n    emitMissed = false,\n    emitOnBegin = false,\n    onBlock,\n    onError,\n    includeTransactions: includeTransactions_,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlocksParameters<transport, chain, includeTransactions, blockTag>,\n): WatchBlocksReturnType {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n  const includeTransactions = includeTransactions_ ?? false\n\n  let prevBlock:\n    | GetBlockReturnType<chain, false | includeTransactions, 'latest'>\n    | undefined\n\n  const pollBlocks = () => {\n    const observerId = stringify([\n      'watchBlocks',\n      client.uid,\n      blockTag,\n      emitMissed,\n      emitOnBegin,\n      includeTransactions,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlock, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const block = await getAction(\n              client,\n              getBlock,\n              'getBlock',\n            )({\n              blockTag,\n              includeTransactions,\n            })\n            if (block.number !== null && prevBlock?.number != null) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (block.number === prevBlock.number) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (block.number - prevBlock.number > 1 && emitMissed) {\n                for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                  const block = (await getAction(\n                    client,\n                    getBlock,\n                    'getBlock',\n                  )({\n                    blockNumber: i,\n                    includeTransactions,\n                  })) as GetBlockReturnType<chain>\n                  emit.onBlock(block as any, prevBlock as any)\n                  prevBlock = block\n                }\n              }\n            }\n\n            if (\n              // If no previous block exists, emit.\n              prevBlock?.number == null ||\n              // If the block tag is \"pending\" with no block number, emit.\n              (blockTag === 'pending' && block?.number == null) ||\n              // If the next block number is greater than the previous block number, emit.\n              // We don't want to emit blocks in the past.\n              (block.number !== null && block.number > prevBlock.number)\n            ) {\n              emit.onBlock(block as any, prevBlock as any)\n              prevBlock = block as any\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlocks = () => {\n    let active = true\n    let emitFetched = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        if (emitOnBegin) {\n          getAction(\n            client,\n            getBlock,\n            'getBlock',\n          )({\n            blockTag,\n            includeTransactions,\n          })\n            .then((block) => {\n              if (!active) return\n              if (!emitFetched) return\n              onBlock(block as any, undefined)\n              emitFetched = false\n            })\n            .catch(onError)\n        }\n\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(\n              (transport: ReturnType<Transport>) =>\n                transport.config.type === 'webSocket' ||\n                transport.config.type === 'ipc',\n            )\n            if (!transport) return client.transport\n            return transport.value\n          }\n          return client.transport\n        })()\n\n        const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n          params: ['newHeads'],\n          async onData(data: any) {\n            if (!active) return\n            const block = (await getAction(\n              client,\n              getBlock,\n              'getBlock',\n            )({\n              blockNumber: data.result?.number,\n              includeTransactions,\n            }).catch(() => {})) as GetBlockReturnType<chain>\n            if (!active) return\n            onBlock(block as any, prevBlock as any)\n            emitFetched = false\n            prevBlock = block\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return () => unsubscribe()\n  }\n\n  return enablePolling ? pollBlocks() : subscribeBlocks()\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/watchContractEvent.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/watchContractEvent.ts"],"sourcesContent":["import type { Abi, Address, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport type { GetPollOptions } from '../../types/transport.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\nimport { createContractEventFilter } from './createContractEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport {\n  type GetContractEventsParameters,\n  getContractEvents,\n} from './getContractEvents.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchContractEventOnLogsParameter<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n> = abi extends Abi\n  ? Abi extends abi\n    ? Log[]\n    : Log<bigint, number, false, ExtractAbiEvent<abi, eventName>, strict>[]\n  : Log[]\n\nexport type WatchContractEventOnLogsFn<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n> = (logs: WatchContractEventOnLogsParameter<abi, eventName, strict>) => void\n\nexport type WatchContractEventParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Contract ABI. */\n  abi: abi\n  args?:\n    | ContractEventArgs<\n        abi,\n        eventName extends ContractEventName<abi>\n          ? eventName\n          : ContractEventName<abi>\n      >\n    | undefined\n  /** Contract event. */\n  eventName?: eventName | ContractEventName<abi> | undefined\n  /** Block to start listening from. */\n  fromBlock?: BlockNumber<bigint> | undefined\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchContractEventOnLogsFn<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    strict\n  >\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: strict | boolean | undefined\n} & GetPollOptions<transport>\n\nexport type WatchContractEventReturnType = () => void\n\nexport type WatchContractEventErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n>(\n  client: Client<transport, chain>,\n  parameters: WatchContractEventParameters<abi, eventName, strict, transport>,\n): WatchContractEventReturnType {\n  const {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  } = parameters\n\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (typeof fromBlock === 'bigint') return true\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n\n  const pollContractEvent = () => {\n    const strict = strict_ ?? false\n    const observerId = stringify([\n      'watchContractEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      eventName,\n      pollingInterval,\n      strict,\n      fromBlock,\n    ])\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n\n      let filter: Filter<'event', abi, eventName> | undefined\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await getAction(\n                client,\n                createContractEventFilter,\n                'createContractEventFilter',\n              )({\n                abi,\n                address,\n                args: args as any,\n                eventName: eventName as any,\n                strict: strict as any,\n                fromBlock,\n              })) as Filter<'event', abi, eventName>\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getAction(\n                client,\n                getFilterChanges,\n                'getFilterChanges',\n              )({ filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getAction(\n                client,\n                getBlockNumber,\n                'getBlockNumber',\n              )({})\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber < blockNumber) {\n                logs = await getAction(\n                  client,\n                  getContractEvents,\n                  'getContractEvents',\n                )({\n                  abi,\n                  address,\n                  args,\n                  eventName,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                  strict,\n                } as {} as GetContractEventsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else for (const log of logs) emit.onLogs([log] as any)\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitialize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeContractEvent = () => {\n    const strict = strict_ ?? false\n    const observerId = stringify([\n      'watchContractEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      eventName,\n      pollingInterval,\n      strict,\n    ])\n\n    let active = true\n    let unsubscribe = () => (active = false)\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      ;(async () => {\n        try {\n          const transport = (() => {\n            if (client.transport.type === 'fallback') {\n              const transport = client.transport.transports.find(\n                (transport: ReturnType<Transport>) =>\n                  transport.config.type === 'webSocket' ||\n                  transport.config.type === 'ipc',\n              )\n              if (!transport) return client.transport\n              return transport.value\n            }\n            return client.transport\n          })()\n\n          const topics: LogTopic[] = eventName\n            ? encodeEventTopics({\n                abi: abi,\n                eventName: eventName,\n                args,\n              } as EncodeEventTopicsParameters)\n            : []\n\n          const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n            params: ['logs', { address, topics }],\n            onData(data: any) {\n              if (!active) return\n              const log = data.result\n              try {\n                const { eventName, args } = decodeEventLog({\n                  abi: abi,\n                  data: log.data,\n                  topics: log.topics as any,\n                  strict: strict_,\n                })\n                const formatted = formatLog(log, {\n                  args,\n                  eventName: eventName as string,\n                })\n                emit.onLogs([formatted] as any)\n              } catch (err) {\n                let eventName: string | undefined\n                let isUnnamed: boolean | undefined\n                if (\n                  err instanceof DecodeLogDataMismatch ||\n                  err instanceof DecodeLogTopicsMismatch\n                ) {\n                  // If strict mode is on, and log data/topics do not match event definition, skip.\n                  if (strict_) return\n                  eventName = err.abiItem.name\n                  isUnnamed = err.abiItem.inputs?.some(\n                    (x) => !('name' in x && x.name),\n                  )\n                }\n\n                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n                const formatted = formatLog(log, {\n                  args: isUnnamed ? [] : {},\n                  eventName,\n                })\n                emit.onLogs([formatted] as any)\n              }\n            },\n            onError(error: Error) {\n              emit.onError?.(error)\n            },\n          })\n          unsubscribe = unsubscribe_\n          if (!active) unsubscribe()\n        } catch (err) {\n          onError?.(err as Error)\n        }\n      })()\n      return () => unsubscribe()\n    })\n  }\n\n  return enablePolling ? pollContractEvent() : subscribeContractEvent()\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2065, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/public/watchEvent.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/public/watchEvent.ts"],"sourcesContent":["import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport type { GetPollOptions } from '../../types/transport.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\nimport {\n  type CreateEventFilterParameters,\n  createEventFilter,\n} from './createEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { type GetLogsParameters, getLogs } from './getLogs.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchEventOnLogsParameter<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = Log<bigint, number, false, abiEvent, strict, abiEvents, eventName>[]\nexport type WatchEventOnLogsFn<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = (\n  logs: WatchEventOnLogsParameter<abiEvent, abiEvents, strict, _eventName>,\n) => void\n\nexport type WatchEventParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Block to start listening from. */\n  fromBlock?: BlockNumber<bigint> | undefined\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchEventOnLogsFn<abiEvent, abiEvents, strict, _eventName>\n} & GetPollOptions<transport> &\n  (\n    | {\n        event: abiEvent\n        events?: undefined\n        args?: MaybeExtractEventArgsFromAbi<abiEvents, _eventName> | undefined\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: strict | undefined\n      }\n    | {\n        event?: undefined\n        events?: abiEvents | undefined\n        args?: undefined\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: strict | undefined\n      }\n    | {\n        event?: undefined\n        events?: undefined\n        args?: undefined\n        strict?: undefined\n      }\n  )\n\nexport type WatchEventReturnType = () => void\n\nexport type WatchEventErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n  _eventName extends string | undefined = undefined,\n>(\n  client: Client<transport, chain>,\n  {\n    address,\n    args,\n    batch = true,\n    event,\n    events,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchEventParameters<abiEvent, abiEvents, strict, transport>,\n): WatchEventReturnType {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (typeof fromBlock === 'bigint') return true\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n  const strict = strict_ ?? false\n\n  const pollEvent = () => {\n    const observerId = stringify([\n      'watchEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      event,\n      pollingInterval,\n      fromBlock,\n    ])\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n\n      let filter: Filter<'event', abiEvents, _eventName, any>\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await getAction(\n                client,\n                createEventFilter as any,\n                'createEventFilter',\n              )({\n                address,\n                args,\n                event: event!,\n                events,\n                strict,\n                fromBlock,\n              } as unknown as CreateEventFilterParameters)) as unknown as Filter<\n                'event',\n                abiEvents,\n                _eventName\n              >\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getAction(\n                client,\n                getFilterChanges,\n                'getFilterChanges',\n              )({ filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getAction(\n                client,\n                getBlockNumber,\n                'getBlockNumber',\n              )({})\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n                logs = await getAction(\n                  client,\n                  getLogs,\n                  'getLogs',\n                )({\n                  address,\n                  args,\n                  event: event!,\n                  events,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                } as unknown as GetLogsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else for (const log of logs) emit.onLogs([log] as any)\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitialize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeEvent = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(\n              (transport: ReturnType<Transport>) =>\n                transport.config.type === 'webSocket' ||\n                transport.config.type === 'ipc',\n            )\n            if (!transport) return client.transport\n            return transport.value\n          }\n          return client.transport\n        })()\n\n        const events_ = events ?? (event ? [event] : undefined)\n        let topics: LogTopic[] = []\n        if (events_) {\n          const encoded = (events_ as AbiEvent[]).flatMap((event) =>\n            encodeEventTopics({\n              abi: [event],\n              eventName: (event as AbiEvent).name,\n              args,\n            } as EncodeEventTopicsParameters),\n          )\n          // TODO: Clean up type casting\n          topics = [encoded as LogTopic]\n          if (event) topics = topics[0] as LogTopic[]\n        }\n\n        const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n          params: ['logs', { address, topics }],\n          onData(data: any) {\n            if (!active) return\n            const log = data.result\n            try {\n              const { eventName, args } = decodeEventLog({\n                abi: events_ ?? [],\n                data: log.data,\n                topics: log.topics,\n                strict,\n              })\n              const formatted = formatLog(log, { args, eventName })\n              onLogs([formatted] as any)\n            } catch (err) {\n              let eventName: string | undefined\n              let isUnnamed: boolean | undefined\n              if (\n                err instanceof DecodeLogDataMismatch ||\n                err instanceof DecodeLogTopicsMismatch\n              ) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return\n                eventName = err.abiItem.name\n                isUnnamed = err.abiItem.inputs?.some(\n                  (x) => !('name' in x && x.name),\n                )\n              }\n\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName,\n              })\n              onLogs([formatted] as any)\n            }\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return () => unsubscribe()\n  }\n\n  return enablePolling ? pollEvent() : subscribeEvent()\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2284, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/siwe/verifySiweMessage.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/siwe/verifySiweMessage.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { HashMessageErrorType } from '../../utils/signature/hashMessage.js'\nimport { hashMessage } from '../../utils/signature/hashMessage.js'\nimport { parseSiweMessage } from '../../utils/siwe/parseSiweMessage.js'\nimport {\n  type ValidateSiweMessageParameters,\n  validateSiweMessage,\n} from '../../utils/siwe/validateSiweMessage.js'\nimport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  verifyHash,\n} from '../public/verifyHash.js'\n\nexport type VerifySiweMessageParameters = Prettify<\n  Pick<VerifyHashParameters, 'blockNumber' | 'blockTag'> &\n    Pick<\n      ValidateSiweMessageParameters,\n      'address' | 'domain' | 'nonce' | 'scheme' | 'time'\n    > & {\n      /**\n       * EIP-4361 formatted message.\n       */\n      message: string\n      /**\n       * Signature to check against.\n       */\n      signature: Hex\n    }\n>\n\nexport type VerifySiweMessageReturnType = boolean\n\nexport type VerifySiweMessageErrorType =\n  | HashMessageErrorType\n  | VerifyHashErrorType\n  | ErrorType\n\n/**\n * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifySiweMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}\n */\nexport async function verifySiweMessage<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifySiweMessageParameters,\n): Promise<VerifySiweMessageReturnType> {\n  const {\n    address,\n    domain,\n    message,\n    nonce,\n    scheme,\n    signature,\n    time = new Date(),\n    ...callRequest\n  } = parameters\n\n  const parsed = parseSiweMessage(message)\n  if (!parsed.address) return false\n\n  const isValid = validateSiweMessage({\n    address,\n    domain,\n    message: parsed,\n    nonce,\n    scheme,\n    time,\n  })\n  if (!isValid) return false\n\n  const hash = hashMessage(message)\n  return verifyHash(client, {\n    address: parsed.address,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n"],"names":[],"mappings":";;;;AAOA,OAAO,EAAE,WAAW,EAAE,MAAM,sCAAsC,CAAA;AAClE,OAAO,EAAE,gBAAgB,EAAE,MAAM,sCAAsC,CAAA;AACvE,OAAO,EAEL,mBAAmB,GACpB,MAAM,yCAAyC,CAAA;AAChD,OAAO,EAGL,UAAU,GACX,MAAM,yBAAyB,CAAA;;;;;AAqCzB,KAAK,UAAU,iBAAiB,CACrC,MAAgC,EAChC,UAAuC;IAEvC,MAAM,EACJ,OAAO,EACP,MAAM,EACN,OAAO,EACP,KAAK,EACL,MAAM,EACN,SAAS,EACT,IAAI,GAAG,IAAI,IAAI,EAAE,EACjB,GAAG,WAAW,EACf,GAAG,UAAU,CAAA;IAEd,MAAM,MAAM,OAAG,wLAAgB,EAAC,OAAO,CAAC,CAAA;IACxC,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,OAAO,KAAK,CAAA;IAEjC,MAAM,OAAO,OAAG,8LAAmB,EAAC;QAClC,OAAO;QACP,MAAM;QACN,OAAO,EAAE,MAAM;QACf,KAAK;QACL,MAAM;QACN,IAAI;KACL,CAAC,CAAA;IACF,IAAI,CAAC,OAAO,EAAE,OAAO,KAAK,CAAA;IAE1B,MAAM,IAAI,OAAG,mLAAW,EAAC,OAAO,CAAC,CAAA;IACjC,WAAO,gLAAU,EAAC,MAAM,EAAE;QACxB,OAAO,EAAE,MAAM,CAAC,OAAO;QACvB,IAAI;QACJ,SAAS;QACT,GAAG,WAAW;KACf,CAAC,CAAA;AACJ,CAAC","debugId":null}},
    {"offset": {"line": 2321, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/wallet/sendRawTransactionSync.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/wallet/sendRawTransactionSync.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { TransactionReceiptRevertedError } from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { TransactionSerializedGeneric } from '../../types/transaction.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { formatTransactionReceipt } from '../../utils/formatters/transactionReceipt.js'\nimport {\n  type FormattedTransactionReceipt,\n  numberToHex,\n} from '../../utils/index.js'\n\nexport type SendRawTransactionSyncParameters = {\n  /** The signed serialized transaction. */\n  serializedTransaction: TransactionSerializedGeneric\n  /** Whether to throw an error if the transaction was detected as reverted. @default true */\n  throwOnReceiptRevert?: boolean | undefined\n  /** The timeout for the transaction. */\n  timeout?: number | undefined\n}\n\nexport type SendRawTransactionSyncReturnType<\n  chain extends Chain | undefined = undefined,\n> = FormattedTransactionReceipt<chain>\n\nexport type SendRawTransactionSyncErrorType = RequestErrorType | ErrorType\n\n/**\n * Sends a **signed** transaction to the network synchronously,\n * and waits for the transaction to be included in a block.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransactionSync\n * - JSON-RPC Method: [`eth_sendRawTransactionSync`](https://eips.ethereum.org/EIPS/eip-7966)\n *\n * @param client - Client to use\n * @param parameters - {@link SendRawTransactionParameters}\n * @returns The transaction receipt. {@link SendRawTransactionSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendRawTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const receipt = await sendRawTransactionSync(client, {\n *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n * })\n */\nexport async function sendRawTransactionSync<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    serializedTransaction,\n    throwOnReceiptRevert,\n    timeout,\n  }: SendRawTransactionSyncParameters,\n): Promise<SendRawTransactionSyncReturnType<chain>> {\n  const receipt = await client.request(\n    {\n      method: 'eth_sendRawTransactionSync',\n      params: timeout\n        ? [serializedTransaction, numberToHex(timeout)]\n        : [serializedTransaction],\n    },\n    { retryCount: 0 },\n  )\n  const format =\n    client.chain?.formatters?.transactionReceipt?.format ||\n    formatTransactionReceipt\n\n  const formatted = format(receipt) as SendRawTransactionSyncReturnType<chain>\n  if (formatted.status === 'reverted' && throwOnReceiptRevert)\n    throw new TransactionReceiptRevertedError({ receipt: formatted })\n  return formatted\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,+BAA+B,EAAE,MAAM,6BAA6B,CAAA;AAK7E,OAAO,EAAE,wBAAwB,EAAE,MAAM,8CAA8C,CAAA;AACvF,OAAO,EAEL,WAAW,GACZ,MAAM,sBAAsB,CAAA;;;;AA0CtB,KAAK,UAAU,sBAAsB,CAC1C,MAAgC,EAChC,EACE,qBAAqB,EACrB,oBAAoB,EACpB,OAAO,EAC0B;IAEnC,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,OAAO,CAClC;QACE,MAAM,EAAE,4BAA4B;QACpC,MAAM,EAAE,OAAO,GACX;YAAC,qBAAqB;gBAAE,4KAAW,EAAC,OAAO,CAAC;SAAC,GAC7C;YAAC,qBAAqB;SAAC;KAC5B,EACD;QAAE,UAAU,EAAE,CAAC;IAAA,CAAE,CAClB,CAAA;IACD,MAAM,MAAM,GACV,MAAM,CAAC,KAAK,EAAE,UAAU,EAAE,kBAAkB,EAAE,MAAM,IACpD,wMAAwB,CAAA;IAE1B,MAAM,SAAS,GAAG,MAAM,CAAC,OAAO,CAA4C,CAAA;IAC5E,IAAI,SAAS,CAAC,MAAM,KAAK,UAAU,IAAI,oBAAoB,EACzD,MAAM,IAAI,2LAA+B,CAAC;QAAE,OAAO,EAAE,SAAS;IAAA,CAAE,CAAC,CAAA;IACnE,OAAO,SAAS,CAAA;AAClB,CAAC","debugId":null}},
    {"offset": {"line": 2354, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/wallet/prepareAuthorization.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/wallet/prepareAuthorization.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Authorization,\n  AuthorizationRequest,\n} from '../../types/authorization.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { PartialBy } from '../../types/utils.js'\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { getChainId } from '../public/getChainId.js'\nimport { getTransactionCount } from '../public/getTransactionCount.js'\n\nexport type PrepareAuthorizationParameters<\n  account extends Account | undefined = Account | undefined,\n> = GetAccountParameter<account> &\n  PartialBy<AuthorizationRequest, 'chainId' | 'nonce'> & {\n    /**\n     * Whether the EIP-7702 Transaction will be executed by the EOA (signing this Authorization) or another Account.\n     *\n     * By default, it will be assumed that the EIP-7702 Transaction will\n     * be executed by another Account.\n     */\n    executor?: 'self' | Account | Address | undefined\n  }\n\nexport type PrepareAuthorizationReturnType = Authorization\n\nexport type PrepareAuthorizationErrorType =\n  | ParseAccountErrorType\n  | RequestErrorType\n  | AccountNotFoundErrorType\n  | ErrorType\n\n/**\n * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n *\n * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link PrepareAuthorizationParameters}\n * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function prepareAuthorization<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: PrepareAuthorizationParameters<account>,\n): Promise<PrepareAuthorizationReturnType> {\n  const { account: account_ = client.account, chainId, nonce } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/eip7702/prepareAuthorization',\n    })\n  const account = parseAccount(account_)\n\n  const executor = (() => {\n    if (!parameters.executor) return undefined\n    if (parameters.executor === 'self') return parameters.executor\n    return parseAccount(parameters.executor)\n  })()\n\n  const authorization = {\n    address: parameters.contractAddress ?? parameters.address,\n    chainId,\n    nonce,\n  } as Authorization\n\n  if (typeof authorization.chainId === 'undefined')\n    authorization.chainId =\n      client.chain?.id ??\n      (await getAction(client, getChainId, 'getChainId')({}))\n\n  if (typeof authorization.nonce === 'undefined') {\n    authorization.nonce = await getAction(\n      client,\n      getTransactionCount,\n      'getTransactionCount',\n    )({\n      address: account.address,\n      blockTag: 'pending',\n    })\n    if (\n      executor === 'self' ||\n      (executor?.address && isAddressEqual(executor.address, account.address))\n    )\n      authorization.nonce += 1\n  }\n\n  return authorization\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAEL,YAAY,GACb,MAAM,sCAAsC,CAAA;AAG7C,OAAO,EACL,oBAAoB,GAErB,MAAM,yBAAyB,CAAA;AAShC,OAAO,EAAE,cAAc,EAAE,MAAM,uCAAuC,CAAA;AAEtE,OAAO,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAA;AACpD,OAAO,EAAE,UAAU,EAAE,MAAM,yBAAyB,CAAA;AACpD,OAAO,EAAE,mBAAmB,EAAE,MAAM,kCAAkC,CAAA;;;;;;;AAgE/D,KAAK,UAAU,oBAAoB,CAIxC,MAAyC,EACzC,UAAmD;IAEnD,MAAM,EAAE,OAAO,EAAE,QAAQ,GAAG,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,UAAU,CAAA;IAEzE,IAAI,CAAC,QAAQ,EACX,MAAM,IAAI,4KAAoB,CAAC;QAC7B,QAAQ,EAAE,oCAAoC;KAC/C,CAAC,CAAA;IACJ,MAAM,OAAO,OAAG,oLAAY,EAAC,QAAQ,CAAC,CAAA;IAEtC,MAAM,QAAQ,GAAG,CAAC,GAAG,EAAE;QACrB,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,OAAO,SAAS,CAAA;QAC1C,IAAI,UAAU,CAAC,QAAQ,KAAK,MAAM,EAAE,OAAO,UAAU,CAAC,QAAQ,CAAA;QAC9D,WAAO,oLAAY,EAAC,UAAU,CAAC,QAAQ,CAAC,CAAA;IAC1C,CAAC,CAAC,EAAE,CAAA;IAEJ,MAAM,aAAa,GAAG;QACpB,OAAO,EAAE,UAAU,CAAC,eAAe,IAAI,UAAU,CAAC,OAAO;QACzD,OAAO;QACP,KAAK;KACW,CAAA;IAElB,IAAI,OAAO,aAAa,CAAC,OAAO,KAAK,WAAW,EAC9C,aAAa,CAAC,OAAO,GACnB,MAAM,CAAC,KAAK,EAAE,EAAE,IACf,UAAM,kKAAS,EAAC,MAAM,EAAE,gLAAU,EAAE,YAAY,CAAC,CAAC,CAAA,CAAE,CAAC,CAAC,CAAA;IAE3D,IAAI,OAAO,aAAa,CAAC,KAAK,KAAK,WAAW,EAAE,CAAC;QAC/C,aAAa,CAAC,KAAK,GAAG,UAAM,kKAAS,EACnC,MAAM,EACN,kMAAmB,EACnB,qBAAqB,CACtB,CAAC;YACA,OAAO,EAAE,OAAO,CAAC,OAAO;YACxB,QAAQ,EAAE,SAAS;SACpB,CAAC,CAAA;QACF,IACE,QAAQ,KAAK,MAAM,IAClB,QAAQ,EAAE,OAAO,QAAI,uLAAc,EAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC,CAExE,aAAa,CAAC,KAAK,IAAI,CAAC,CAAA;IAC5B,CAAC;IAED,OAAO,aAAa,CAAA;AACtB,CAAC","debugId":null}},
    {"offset": {"line": 2400, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/wallet/sendCalls.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/wallet/sendCalls.ts"],"sourcesContent":["import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  AtomicityNotSupportedError,\n  UnsupportedNonOptionalCapabilityError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { WalletSendCallsParameters } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { concat } from '../../utils/data/concat.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js'\nimport { sendTransaction } from './sendTransaction.js'\n\nexport const fallbackMagicIdentifier =\n  '0x5792579257925792579257925792579257925792579257925792579257925792'\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n  size: 32,\n})\n\nexport type SendCallsParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _chain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  chain?: chainOverride | Chain | undefined\n  calls: Calls<Narrow<calls>>\n  capabilities?: ExtractCapabilities<'sendCalls', 'Request'> | undefined\n  experimental_fallback?: boolean | undefined\n  experimental_fallbackDelay?: number | undefined\n  forceAtomic?: boolean | undefined\n  id?: string | undefined\n  version?: WalletSendCallsParameters[number]['version'] | undefined\n} & GetAccountParameter<account, Account | Address, false, true>\n\nexport type SendCallsReturnType = Prettify<{\n  capabilities?: ExtractCapabilities<'sendCalls', 'ReturnType'> | undefined\n  id: string\n}>\n\nexport type SendCallsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsReturnType> {\n  const {\n    account: account_ = client.account,\n    capabilities,\n    chain = client.chain,\n    experimental_fallback,\n    experimental_fallbackDelay = 32,\n    forceAtomic = false,\n    id,\n    version = '2.0.0',\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : null\n\n  const calls = parameters.calls.map((call_: unknown) => {\n    const call = call_ as Call\n\n    const data = call.abi\n      ? encodeFunctionData({\n          abi: call.abi,\n          functionName: call.functionName,\n          args: call.args,\n        })\n      : call.data\n\n    return {\n      data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n      to: call.to,\n      value: call.value ? numberToHex(call.value) : undefined,\n    }\n  })\n\n  try {\n    const response = await client.request(\n      {\n        method: 'wallet_sendCalls',\n        params: [\n          {\n            atomicRequired: forceAtomic,\n            calls,\n            capabilities,\n            chainId: numberToHex(chain!.id),\n            from: account?.address,\n            id,\n            version,\n          },\n        ],\n      },\n      { retryCount: 0 },\n    )\n    if (typeof response === 'string') return { id: response }\n    return response as never\n  } catch (err) {\n    const error = err as BaseError\n\n    // If the transport does not support EIP-5792, fall back to\n    // `eth_sendTransaction`.\n    if (\n      experimental_fallback &&\n      (error.name === 'MethodNotFoundRpcError' ||\n        error.name === 'MethodNotSupportedRpcError' ||\n        error.name === 'UnknownRpcError' ||\n        error.details\n          .toLowerCase()\n          .includes('does not exist / is not available') ||\n        error.details.toLowerCase().includes('missing or invalid. request()') ||\n        error.details\n          .toLowerCase()\n          .includes('did not match any variant of untagged enum') ||\n        error.details\n          .toLowerCase()\n          .includes('account upgraded to unsupported contract') ||\n        error.details.toLowerCase().includes('eip-7702 not supported') ||\n        error.details.toLowerCase().includes('unsupported wc_ method') ||\n        // magic.link\n        error.details\n          .toLowerCase()\n          .includes('feature toggled misconfigured') ||\n        // Trust Wallet\n        error.details\n          .toLowerCase()\n          .includes(\n            'jsonrpcengine: response has no error or result for request',\n          ))\n    ) {\n      if (capabilities) {\n        const hasNonOptionalCapability = Object.values(capabilities).some(\n          (capability) => !capability.optional,\n        )\n        if (hasNonOptionalCapability) {\n          const message =\n            'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.'\n          throw new UnsupportedNonOptionalCapabilityError(\n            new BaseError(message, {\n              details: message,\n            }),\n          )\n        }\n      }\n      if (forceAtomic && calls.length > 1) {\n        const message =\n          '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.'\n        throw new AtomicityNotSupportedError(\n          new BaseError(message, {\n            details: message,\n          }),\n        )\n      }\n\n      const promises: Promise<Hex>[] = []\n      for (const call of calls) {\n        const promise = sendTransaction(client, {\n          account,\n          chain,\n          data: call.data,\n          to: call.to,\n          value: call.value ? hexToBigInt(call.value) : undefined,\n        })\n        promises.push(promise)\n\n        // Note: some browser wallets require a small delay between transactions\n        // to prevent duplicate JSON-RPC requests.\n        if (experimental_fallbackDelay > 0)\n          await new Promise((resolve) =>\n            setTimeout(resolve, experimental_fallbackDelay),\n          )\n      }\n\n      const results = await Promise.allSettled(promises)\n      if (results.every((r) => r.status === 'rejected')) throw results[0].reason\n\n      const hashes = results.map((result) => {\n        if (result.status === 'fulfilled') return result.value\n        return fallbackTransactionErrorMagicIdentifier\n      })\n      return {\n        id: concat([\n          ...hashes,\n          numberToHex(chain!.id, { size: 32 }),\n          fallbackMagicIdentifier,\n        ]),\n      }\n    }\n\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain!,\n    })\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2533, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/wallet/getCallsStatus.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/wallet/getCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletGetCallsStatusReturnType } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { sliceHex } from '../../utils/data/slice.js'\nimport { trim } from '../../utils/data/trim.js'\nimport { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js'\nimport { receiptStatuses } from '../../utils/formatters/transactionReceipt.js'\nimport {\n  fallbackMagicIdentifier,\n  fallbackTransactionErrorMagicIdentifier,\n} from './sendCalls.js'\n\nexport type GetCallsStatusParameters = { id: string }\n\nexport type GetCallsStatusReturnType = Prettify<\n  Omit<\n    WalletGetCallsStatusReturnType<\n      ExtractCapabilities<'getCallsStatus', 'ReturnType'>,\n      number,\n      bigint,\n      'success' | 'reverted'\n    >,\n    'status'\n  > & {\n    statusCode: number\n    status: 'pending' | 'success' | 'failure' | undefined\n  }\n>\n\nexport type GetCallsStatusErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the status of a call batch that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link GetCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function getCallsStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetCallsStatusParameters,\n): Promise<GetCallsStatusReturnType> {\n  async function getStatus(id: Hex) {\n    const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2))\n    if (isTransactions) {\n      const chainId = trim(sliceHex(id, -64, -32))\n      const hashes = sliceHex(id, 0, -64)\n        .slice(2)\n        .match(/.{1,64}/g)\n\n      const receipts = await Promise.all(\n        hashes!.map((hash) =>\n          fallbackTransactionErrorMagicIdentifier.slice(2) !== hash\n            ? client.request(\n                {\n                  method: 'eth_getTransactionReceipt',\n                  params: [`0x${hash}`],\n                },\n                { dedupe: true },\n              )\n            : undefined,\n        ),\n      )\n\n      const status = (() => {\n        if (receipts.some((r) => r === null)) return 100 // pending\n        if (receipts.every((r) => r?.status === '0x1')) return 200 // success\n        if (receipts.every((r) => r?.status === '0x0')) return 500 // complete failure\n        return 600 // partial failure\n      })()\n\n      return {\n        atomic: false,\n        chainId: hexToNumber(chainId),\n        receipts: receipts.filter(Boolean) as RpcTransactionReceipt[],\n        status,\n        version: '2.0.0',\n      }\n    }\n    return client.request({\n      method: 'wallet_getCallsStatus',\n      params: [id],\n    })\n  }\n\n  const {\n    atomic = false,\n    chainId,\n    receipts,\n    version = '2.0.0',\n    ...response\n  } = await getStatus(parameters.id as Hex)\n  const [status, statusCode] = (() => {\n    const statusCode = response.status\n    if (statusCode >= 100 && statusCode < 200)\n      return ['pending', statusCode] as const\n    if (statusCode >= 200 && statusCode < 300)\n      return ['success', statusCode] as const\n    if (statusCode >= 300 && statusCode < 700)\n      return ['failure', statusCode] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'CONFIRMED') return ['success', 200] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'PENDING') return ['pending', 100] as const\n    return [undefined, statusCode]\n  })()\n  return {\n    ...response,\n    atomic,\n    // @ts-expect-error: for backwards compatibility\n    chainId: chainId ? hexToNumber(chainId) : undefined,\n    receipts:\n      receipts?.map((receipt) => ({\n        ...receipt,\n        blockNumber: hexToBigInt(receipt.blockNumber),\n        gasUsed: hexToBigInt(receipt.gasUsed),\n        status: receiptStatuses[receipt.status as '0x0' | '0x1'],\n      })) ?? [],\n    statusCode,\n    status,\n    version,\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2632, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js","sources":["file:///c:/Users/MOHD%20UMAIR/Desktop/halloween%20spin/node_modules/viem/actions/wallet/waitForCallsStatus.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport { BundleFailedError } from '../../errors/calls.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the call bundle failed.\n   * @default 4 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Whether to throw an error if the call bundle fails.\n   *\n   * @default false\n   */\n  throwOnFailure?: boolean | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await withRetry(\n            async () => {\n              const result = await getAction(\n                client,\n                getCallsStatus,\n                'getCallsStatus',\n              )({ id })\n              if (throwOnFailure && result.status === 'failure')\n                throw new BundleFailedError(result)\n              return result\n            },\n            {\n              retryCount,\n              delay: retryDelay,\n            },\n          )\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}