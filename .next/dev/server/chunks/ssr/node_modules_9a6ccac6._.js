module.exports = [
"[project]/node_modules/@wagmi/connectors/dist/esm/exports/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// biome-ignore lint/performance/noBarrelFile: entrypoint module
__turbopack_context__.s([]);
;
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/baseAccount.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "baseAccount",
    ()=>baseAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-ssr] (ecmascript)");
;
;
function baseAccount(parameters = {}) {
    let walletProvider;
    let accountsChanged;
    let chainChanged;
    let disconnect;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'baseAccount',
            name: 'Base Account',
            rdns: 'app.base.account',
            type: 'baseAccount',
            async connect ({ chainId, withCapabilities } = {}) {
                try {
                    const provider = await this.getProvider();
                    const accounts = (await provider.request({
                        method: 'eth_requestAccounts',
                        params: []
                    })).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', accountsChanged);
                    }
                    if (!chainChanged) {
                        chainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', chainChanged);
                    }
                    if (!disconnect) {
                        disconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', disconnect);
                    }
                    // Switch to chain if provided
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({
                            chainId
                        }).catch((error)=>{
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw error;
                            return {
                                id: currentChainId
                            };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    return {
                        // TODO(v3): Make `withCapabilities: true` default behavior
                        accounts: withCapabilities ? accounts.map((address)=>({
                                address,
                                capabilities: {}
                            })) : accounts,
                        chainId: currentChainId
                    };
                } catch (error) {
                    if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    throw error;
                }
            },
            async disconnect () {
                const provider = await this.getProvider();
                if (accountsChanged) {
                    provider.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                provider.disconnect();
            },
            async getAccounts () {
                const provider = await this.getProvider();
                return (await provider.request({
                    method: 'eth_accounts'
                })).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getChainId () {
                const provider = await this.getProvider();
                const chainId = await provider.request({
                    method: 'eth_chainId'
                });
                return Number(chainId);
            },
            async getProvider () {
                if (!walletProvider) {
                    const preference = (()=>{
                        if (typeof parameters.preference === 'string') return {
                            options: parameters.preference
                        };
                        return {
                            ...parameters.preference,
                            options: parameters.preference?.options ?? 'all'
                        };
                    })();
                    const { createBaseAccountSDK } = await __turbopack_context__.A("[project]/node_modules/@base-org/account/dist/index.node.js [app-ssr] (ecmascript, async loader)");
                    const sdk = createBaseAccountSDK({
                        ...parameters,
                        appChainIds: config.chains.map((x)=>x.id),
                        preference
                    });
                    walletProvider = sdk.getProvider();
                }
                return walletProvider;
            },
            async isAuthorized () {
                try {
                    const accounts = await this.getAccounts();
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            async switchChain ({ addEthereumChainParameter, chainId }) {
                const chain = config.chains.find((chain)=>chain.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                const provider = await this.getProvider();
                try {
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [
                            {
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chain.id)
                            }
                        ]
                    });
                    return chain;
                } catch (error) {
                    // Indicates chain is not added to provider
                    if (error.code === 4902) {
                        try {
                            let blockExplorerUrls;
                            if (addEthereumChainParameter?.blockExplorerUrls) blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
                            else blockExplorerUrls = chain.blockExplorers?.default.url ? [
                                chain.blockExplorers?.default.url
                            ] : [];
                            let rpcUrls;
                            if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;
                            else rpcUrls = [
                                chain.rpcUrls.default?.http[0] ?? ''
                            ];
                            const addEthereumChain = {
                                blockExplorerUrls,
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId),
                                chainName: addEthereumChainParameter?.chainName ?? chain.name,
                                iconUrls: addEthereumChainParameter?.iconUrls,
                                nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
                                rpcUrls
                            };
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [
                                    addEthereumChain
                                ]
                            });
                            return chain;
                        } catch (error) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                        }
                    }
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](error);
                }
            },
            onAccountsChanged (accounts) {
                if (accounts.length === 0) this.onDisconnect();
                else config.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                config.emitter.emit('disconnect');
                const provider = await this.getProvider();
                if (accountsChanged) {
                    provider.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
            }
        }));
} //# sourceMappingURL=baseAccount.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "coinbaseWallet",
    ()=>coinbaseWallet
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-ssr] (ecmascript)");
;
;
coinbaseWallet.type = 'coinbaseWallet';
function coinbaseWallet(parameters = {}) {
    if (parameters.version === '3' || parameters.headlessMode) return version3(parameters);
    return version4(parameters);
}
function version4(parameters) {
    let walletProvider;
    let accountsChanged;
    let chainChanged;
    let disconnect;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'coinbaseWalletSDK',
            name: 'Coinbase Wallet',
            rdns: 'com.coinbase.wallet',
            type: coinbaseWallet.type,
            async connect ({ chainId, withCapabilities, ...rest } = {}) {
                try {
                    const provider = await this.getProvider();
                    const accounts = (await provider.request({
                        method: 'eth_requestAccounts',
                        params: 'instantOnboarding' in rest && rest.instantOnboarding ? [
                            {
                                onboarding: 'instant'
                            }
                        ] : []
                    })).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', accountsChanged);
                    }
                    if (!chainChanged) {
                        chainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', chainChanged);
                    }
                    if (!disconnect) {
                        disconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', disconnect);
                    }
                    // Switch to chain if provided
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({
                            chainId
                        }).catch((error)=>{
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw error;
                            return {
                                id: currentChainId
                            };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    return {
                        accounts: withCapabilities ? accounts.map((address)=>({
                                address,
                                capabilities: {}
                            })) : accounts,
                        chainId: currentChainId
                    };
                } catch (error) {
                    if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    throw error;
                }
            },
            async disconnect () {
                const provider = await this.getProvider();
                if (accountsChanged) {
                    provider.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                provider.disconnect();
                provider.close?.();
            },
            async getAccounts () {
                const provider = await this.getProvider();
                return (await provider.request({
                    method: 'eth_accounts'
                })).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getChainId () {
                const provider = await this.getProvider();
                const chainId = await provider.request({
                    method: 'eth_chainId'
                });
                return Number(chainId);
            },
            async getProvider () {
                if (!walletProvider) {
                    const preference = (()=>{
                        if (typeof parameters.preference === 'string') return {
                            options: parameters.preference
                        };
                        return {
                            ...parameters.preference,
                            options: parameters.preference?.options ?? 'all'
                        };
                    })();
                    const { createCoinbaseWalletSDK } = await __turbopack_context__.A("[project]/node_modules/@coinbase/wallet-sdk/dist/index.js [app-ssr] (ecmascript, async loader)");
                    const sdk = createCoinbaseWalletSDK({
                        ...parameters,
                        appChainIds: config.chains.map((x)=>x.id),
                        preference
                    });
                    walletProvider = sdk.getProvider();
                }
                return walletProvider;
            },
            async isAuthorized () {
                try {
                    const accounts = await this.getAccounts();
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            async switchChain ({ addEthereumChainParameter, chainId }) {
                const chain = config.chains.find((chain)=>chain.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                const provider = await this.getProvider();
                try {
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [
                            {
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chain.id)
                            }
                        ]
                    });
                    return chain;
                } catch (error) {
                    // Indicates chain is not added to provider
                    if (error.code === 4902) {
                        try {
                            let blockExplorerUrls;
                            if (addEthereumChainParameter?.blockExplorerUrls) blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
                            else blockExplorerUrls = chain.blockExplorers?.default.url ? [
                                chain.blockExplorers?.default.url
                            ] : [];
                            let rpcUrls;
                            if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;
                            else rpcUrls = [
                                chain.rpcUrls.default?.http[0] ?? ''
                            ];
                            const addEthereumChain = {
                                blockExplorerUrls,
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId),
                                chainName: addEthereumChainParameter?.chainName ?? chain.name,
                                iconUrls: addEthereumChainParameter?.iconUrls,
                                nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
                                rpcUrls
                            };
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [
                                    addEthereumChain
                                ]
                            });
                            return chain;
                        } catch (error) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                        }
                    }
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](error);
                }
            },
            onAccountsChanged (accounts) {
                if (accounts.length === 0) this.onDisconnect();
                else config.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                config.emitter.emit('disconnect');
                const provider = await this.getProvider();
                if (accountsChanged) {
                    provider.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
            }
        }));
}
function version3(parameters) {
    const reloadOnDisconnect = false;
    let sdk;
    let walletProvider;
    let accountsChanged;
    let chainChanged;
    let disconnect;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'coinbaseWalletSDK',
            name: 'Coinbase Wallet',
            rdns: 'com.coinbase.wallet',
            type: coinbaseWallet.type,
            async connect ({ chainId, withCapabilities } = {}) {
                try {
                    const provider = await this.getProvider();
                    const accounts = (await provider.request({
                        method: 'eth_requestAccounts'
                    })).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', accountsChanged);
                    }
                    if (!chainChanged) {
                        chainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', chainChanged);
                    }
                    if (!disconnect) {
                        disconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', disconnect);
                    }
                    // Switch to chain if provided
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({
                            chainId
                        }).catch((error)=>{
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw error;
                            return {
                                id: currentChainId
                            };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    return {
                        accounts: withCapabilities ? accounts.map((address)=>({
                                address,
                                capabilities: {}
                            })) : accounts,
                        chainId: currentChainId
                    };
                } catch (error) {
                    if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    throw error;
                }
            },
            async disconnect () {
                const provider = await this.getProvider();
                if (accountsChanged) {
                    provider.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                provider.disconnect();
                provider.close();
            },
            async getAccounts () {
                const provider = await this.getProvider();
                return (await provider.request({
                    method: 'eth_accounts'
                })).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getChainId () {
                const provider = await this.getProvider();
                const chainId = await provider.request({
                    method: 'eth_chainId'
                });
                return Number(chainId);
            },
            async getProvider () {
                if (!walletProvider) {
                    // Unwrapping import for Vite compatibility.
                    // See: https://github.com/vitejs/vite/issues/9703
                    const CoinbaseWalletSDK = await (async ()=>{
                        const { default: SDK } = await __turbopack_context__.A("[project]/node_modules/cbw-sdk/dist/index.js [app-ssr] (ecmascript, async loader)");
                        if (typeof SDK !== 'function' && typeof SDK.default === 'function') return SDK.default;
                        return SDK;
                    })();
                    sdk = new CoinbaseWalletSDK({
                        ...parameters,
                        reloadOnDisconnect
                    });
                    // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.
                    const walletExtensionChainId = sdk.walletExtension?.getChainId();
                    const chain = config.chains.find((chain)=>parameters.chainId ? chain.id === parameters.chainId : chain.id === walletExtensionChainId) || config.chains[0];
                    const chainId = parameters.chainId || chain?.id;
                    const jsonRpcUrl = parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0];
                    walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
                }
                return walletProvider;
            },
            async isAuthorized () {
                try {
                    const accounts = await this.getAccounts();
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            async switchChain ({ addEthereumChainParameter, chainId }) {
                const chain = config.chains.find((chain)=>chain.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                const provider = await this.getProvider();
                try {
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [
                            {
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chain.id)
                            }
                        ]
                    });
                    return chain;
                } catch (error) {
                    // Indicates chain is not added to provider
                    if (error.code === 4902) {
                        try {
                            let blockExplorerUrls;
                            if (addEthereumChainParameter?.blockExplorerUrls) blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
                            else blockExplorerUrls = chain.blockExplorers?.default.url ? [
                                chain.blockExplorers?.default.url
                            ] : [];
                            let rpcUrls;
                            if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;
                            else rpcUrls = [
                                chain.rpcUrls.default?.http[0] ?? ''
                            ];
                            const addEthereumChain = {
                                blockExplorerUrls,
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId),
                                chainName: addEthereumChainParameter?.chainName ?? chain.name,
                                iconUrls: addEthereumChainParameter?.iconUrls,
                                nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
                                rpcUrls
                            };
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [
                                    addEthereumChain
                                ]
                            });
                            return chain;
                        } catch (error) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                        }
                    }
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](error);
                }
            },
            onAccountsChanged (accounts) {
                if (accounts.length === 0) this.onDisconnect();
                else config.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                config.emitter.emit('disconnect');
                const provider = await this.getProvider();
                if (accountsChanged) {
                    provider.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
            }
        }));
} //# sourceMappingURL=coinbaseWallet.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/gemini.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "gemini",
    ()=>gemini
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$gemini$2d$wallet$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@gemini-wallet/core/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-ssr] (ecmascript)");
;
;
;
gemini.type = 'gemini';
function gemini(parameters = {}) {
    let walletProvider;
    let onAccountsChanged;
    let onChainChanged;
    let onDisconnect;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'gemini',
            name: 'Gemini Wallet',
            type: gemini.type,
            icon: 'https://keys.gemini.com/images/gemini-wallet-logo.svg',
            async connect ({ chainId, withCapabilities } = {}) {
                try {
                    const provider = await this.getProvider();
                    const accounts = await provider.request({
                        method: 'eth_requestAccounts'
                    });
                    if (!onAccountsChanged) {
                        onAccountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', onAccountsChanged);
                    }
                    if (!onChainChanged) {
                        onChainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', onChainChanged);
                    }
                    if (!onDisconnect) {
                        onDisconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', onDisconnect);
                    }
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({
                            chainId
                        }).catch((error)=>{
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw error;
                            return {
                                id: currentChainId
                            };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    return {
                        // TODO(v3): Make `withCapabilities: true` default behavior
                        accounts: withCapabilities ? accounts.map((address)=>({
                                address,
                                capabilities: {}
                            })) : accounts,
                        chainId: currentChainId
                    };
                } catch (error) {
                    if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    throw error;
                }
            },
            async disconnect () {
                const provider = await this.getProvider();
                if (onAccountsChanged) {
                    provider.removeListener('accountsChanged', onAccountsChanged);
                    onAccountsChanged = undefined;
                }
                if (onChainChanged) {
                    provider.removeListener('chainChanged', onChainChanged);
                    onChainChanged = undefined;
                }
                if (onDisconnect) {
                    provider.removeListener('disconnect', onDisconnect);
                    onDisconnect = undefined;
                }
                await provider.disconnect();
            },
            async getAccounts () {
                const provider = await this.getProvider();
                const accounts = await provider.request({
                    method: 'eth_accounts'
                });
                return accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getChainId () {
                const provider = await this.getProvider();
                const chainId = await provider.request({
                    method: 'eth_chainId'
                });
                return Number(chainId);
            },
            async getProvider () {
                if (!walletProvider) {
                    walletProvider = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$gemini$2d$wallet$2f$core$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GeminiWalletProvider"]({
                        appMetadata: parameters.appMetadata ?? {},
                        chain: {
                            id: config.chains[0]?.id ?? 1,
                            rpcUrl: config.chains[0]?.rpcUrls?.default?.http[0]
                        }
                    });
                }
                return walletProvider;
            },
            async isAuthorized () {
                try {
                    const accounts = await this.getAccounts();
                    return Boolean(accounts.length);
                } catch  {
                    return false;
                }
            },
            async switchChain ({ chainId }) {
                const chain = config.chains.find((chain)=>chain.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                const provider = await this.getProvider();
                try {
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [
                            {
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId)
                            }
                        ]
                    });
                    return chain;
                } catch (error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](error);
                }
            },
            onAccountsChanged (accounts) {
                if (accounts.length === 0) this.onDisconnect();
                else config.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect () {
                config.emitter.emit('disconnect');
                const provider = await this.getProvider();
                if (onAccountsChanged) {
                    provider.removeListener('accountsChanged', onAccountsChanged);
                    onAccountsChanged = undefined;
                }
                if (onChainChanged) {
                    provider.removeListener('chainChanged', onChainChanged);
                    onChainChanged = undefined;
                }
                if (onDisconnect) {
                    provider.removeListener('disconnect', onDisconnect);
                    onDisconnect = undefined;
                }
            }
        }));
} //# sourceMappingURL=gemini.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/metaMask.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "metaMask",
    ()=>metaMask
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$extractRpcUrls$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/utils/extractRpcUrls.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/connector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/fromHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/promise/withRetry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withTimeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/promise/withTimeout.js [app-ssr] (ecmascript)");
;
;
metaMask.type = 'metaMask';
function metaMask(parameters = {}) {
    let sdk;
    let provider;
    let providerPromise;
    let accountsChanged;
    let chainChanged;
    let connect;
    let displayUri;
    let disconnect;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'metaMaskSDK',
            name: 'MetaMask',
            rdns: [
                'io.metamask',
                'io.metamask.mobile'
            ],
            type: metaMask.type,
            async setup () {
                const provider = await this.getProvider();
                if (provider?.on) {
                    if (!connect) {
                        connect = this.onConnect.bind(this);
                        provider.on('connect', connect);
                    }
                    // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).
                    // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', accountsChanged);
                    }
                }
            },
            async connect ({ chainId, isReconnecting, withCapabilities } = {}) {
                const provider = await this.getProvider();
                if (!displayUri) {
                    displayUri = this.onDisplayUri;
                    provider.on('display_uri', displayUri);
                }
                let accounts = [];
                if (isReconnecting) accounts = await this.getAccounts().catch(()=>[]);
                try {
                    let signResponse;
                    let connectWithResponse;
                    if (!accounts?.length) {
                        if (parameters.connectAndSign || parameters.connectWith) {
                            if (parameters.connectAndSign) signResponse = await sdk.connectAndSign({
                                msg: parameters.connectAndSign
                            });
                            else if (parameters.connectWith) connectWithResponse = await sdk.connectWith({
                                method: parameters.connectWith.method,
                                params: parameters.connectWith.params
                            });
                            accounts = await this.getAccounts();
                        } else {
                            const requestedAccounts = await sdk.connect();
                            accounts = requestedAccounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
                        }
                    }
                    // Switch to chain if provided
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({
                            chainId
                        }).catch((error)=>{
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw error;
                            return {
                                id: currentChainId
                            };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    if (displayUri) {
                        provider.removeListener('display_uri', displayUri);
                        displayUri = undefined;
                    }
                    if (signResponse) provider.emit('connectAndSign', {
                        accounts,
                        chainId: currentChainId,
                        signResponse
                    });
                    else if (connectWithResponse) provider.emit('connectWith', {
                        accounts,
                        chainId: currentChainId,
                        connectWithResponse
                    });
                    // Manage EIP-1193 event listeners
                    // https://eips.ethereum.org/EIPS/eip-1193#events
                    if (connect) {
                        provider.removeListener('connect', connect);
                        connect = undefined;
                    }
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', accountsChanged);
                    }
                    if (!chainChanged) {
                        chainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', chainChanged);
                    }
                    if (!disconnect) {
                        disconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', disconnect);
                    }
                    return {
                        // TODO(v3): Make `withCapabilities: true` default behavior
                        accounts: withCapabilities ? accounts.map((address)=>({
                                address,
                                capabilities: {}
                            })) : accounts,
                        chainId: currentChainId
                    };
                } catch (err) {
                    const error = err;
                    if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ResourceUnavailableRpcError"].code) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ResourceUnavailableRpcError"](error);
                    throw error;
                }
            },
            async disconnect () {
                const provider = await this.getProvider();
                // Manage EIP-1193 event listeners
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                if (!connect) {
                    connect = this.onConnect.bind(this);
                    provider.on('connect', connect);
                }
                await sdk.terminate();
            },
            async getAccounts () {
                const provider = await this.getProvider();
                const accounts = await provider.request({
                    method: 'eth_accounts'
                });
                return accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getChainId () {
                const provider = await this.getProvider();
                const chainId = provider.getChainId() || await provider?.request({
                    method: 'eth_chainId'
                });
                return Number(chainId);
            },
            async getProvider () {
                async function initProvider() {
                    // Unwrapping import for Vite compatibility.
                    // See: https://github.com/vitejs/vite/issues/9703
                    const MetaMaskSDK = await (async ()=>{
                        const { default: SDK } = await __turbopack_context__.A("[project]/node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js [app-ssr] (ecmascript, async loader)");
                        if (typeof SDK !== 'function' && typeof SDK.default === 'function') return SDK.default;
                        return SDK;
                    })();
                    const readonlyRPCMap = {};
                    for (const chain of config.chains)readonlyRPCMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chain.id)] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$extractRpcUrls$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractRpcUrls"])({
                        chain,
                        transports: config.transports
                    })?.[0];
                    sdk = new MetaMaskSDK({
                        _source: 'wagmi',
                        forceDeleteProvider: false,
                        forceInjectProvider: false,
                        injectProvider: false,
                        // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`
                        ...parameters,
                        readonlyRPCMap,
                        dappMetadata: {
                            ...parameters.dappMetadata,
                            // Test if name and url are set AND not empty
                            name: parameters.dappMetadata?.name ? parameters.dappMetadata?.name : 'wagmi',
                            url: parameters.dappMetadata?.url ? parameters.dappMetadata?.url : ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'https://wagmi.sh'
                        },
                        useDeeplink: parameters.useDeeplink ?? true
                    });
                    const result = await sdk.init();
                    // On initial load, sometimes `sdk.getProvider` does not return provider.
                    // https://github.com/wevm/wagmi/issues/4367
                    // Use result of `init` call if available.
                    const provider = (()=>{
                        if (result?.activeProvider) return result.activeProvider;
                        return sdk.getProvider();
                    })();
                    if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ProviderNotFoundError"]();
                    return provider;
                }
                if (!provider) {
                    if (!providerPromise) providerPromise = initProvider();
                    provider = await providerPromise;
                }
                return provider;
            },
            async isAuthorized () {
                try {
                    // MetaMask mobile provider sometimes fails to immediately resolve
                    // JSON-RPC requests on page load
                    const timeout = 200;
                    const accounts = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withRetry"])(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withTimeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withTimeout"])(()=>this.getAccounts(), {
                            timeout
                        }), {
                        delay: timeout + 1,
                        retryCount: 3
                    });
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            async switchChain ({ addEthereumChainParameter, chainId }) {
                const provider = await this.getProvider();
                const chain = config.chains.find((x)=>x.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                try {
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [
                            {
                                chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId)
                            }
                        ]
                    });
                    // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.
                    // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.
                    // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via
                    // this callback or an externally emitted `'chainChanged'` event.
                    // https://github.com/MetaMask/metamask-extension/issues/24247
                    await waitForChainIdToSync();
                    await sendAndWaitForChangeEvent(chainId);
                    return chain;
                } catch (err) {
                    const error = err;
                    if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    // Indicates chain is not added to provider
                    if (error.code === 4902 || // Unwrapping for MetaMask Mobile
                    // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
                    error?.data?.originalError?.code === 4902) {
                        try {
                            await provider.request({
                                method: 'wallet_addEthereumChain',
                                params: [
                                    {
                                        blockExplorerUrls: (()=>{
                                            const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
                                            if (addEthereumChainParameter?.blockExplorerUrls) return addEthereumChainParameter.blockExplorerUrls;
                                            if (blockExplorer) return [
                                                blockExplorer.url,
                                                ...Object.values(blockExplorers).map((x)=>x.url)
                                            ];
                                            return;
                                        })(),
                                        chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId),
                                        chainName: addEthereumChainParameter?.chainName ?? chain.name,
                                        iconUrls: addEthereumChainParameter?.iconUrls,
                                        nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
                                        rpcUrls: (()=>{
                                            if (addEthereumChainParameter?.rpcUrls?.length) return addEthereumChainParameter.rpcUrls;
                                            return [
                                                chain.rpcUrls.default?.http[0] ?? ''
                                            ];
                                        })()
                                    }
                                ]
                            });
                            await waitForChainIdToSync();
                            await sendAndWaitForChangeEvent(chainId);
                            return chain;
                        } catch (err) {
                            const error = err;
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](error);
                        }
                    }
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](error);
                }
                async function waitForChainIdToSync() {
                    // On mobile, there is a race condition between the result of `'wallet_addEthereumChain'` and `'eth_chainId'`.
                    // To avoid this, we wait for `'eth_chainId'` to return the expected chain ID with a retry loop.
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withRetry"])(async ()=>{
                        const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToNumber"])(await provider.request({
                            method: 'eth_chainId'
                        }));
                        // `value` doesn't match expected `chainId`, throw to trigger retry
                        if (value !== chainId) throw new Error('User rejected switch after adding network.');
                        return value;
                    }, {
                        delay: 50,
                        retryCount: 20
                    });
                }
                async function sendAndWaitForChangeEvent(chainId) {
                    await new Promise((resolve)=>{
                        const listener = (data)=>{
                            if ('chainId' in data && data.chainId === chainId) {
                                config.emitter.off('change', listener);
                                resolve();
                            }
                        };
                        config.emitter.on('change', listener);
                        config.emitter.emit('change', {
                            chainId
                        });
                    });
                }
            },
            async onAccountsChanged (accounts) {
                // Disconnect if there are no accounts
                if (accounts.length === 0) {
                    // ... and using browser extension
                    if (sdk.isExtensionActive()) this.onDisconnect();
                    else return;
                } else if (config.emitter.listenerCount('connect')) {
                    const chainId = (await this.getChainId()).toString();
                    this.onConnect({
                        chainId
                    });
                } else config.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onConnect (connectInfo) {
                const accounts = await this.getAccounts();
                if (accounts.length === 0) return;
                const chainId = Number(connectInfo.chainId);
                config.emitter.emit('connect', {
                    accounts,
                    chainId
                });
                const provider = await this.getProvider();
                if (connect) {
                    provider.removeListener('connect', connect);
                    connect = undefined;
                }
                if (!accountsChanged) {
                    accountsChanged = this.onAccountsChanged.bind(this);
                    provider.on('accountsChanged', accountsChanged);
                }
                if (!chainChanged) {
                    chainChanged = this.onChainChanged.bind(this);
                    provider.on('chainChanged', chainChanged);
                }
                if (!disconnect) {
                    disconnect = this.onDisconnect.bind(this);
                    provider.on('disconnect', disconnect);
                }
            },
            async onDisconnect (error) {
                const provider = await this.getProvider();
                // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting
                // https://github.com/MetaMask/providers/pull/120
                if (error && error.code === 1013) {
                    if (provider && !!(await this.getAccounts()).length) return;
                }
                config.emitter.emit('disconnect');
                // Manage EIP-1193 event listeners
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                if (!connect) {
                    connect = this.onConnect.bind(this);
                    provider.on('connect', connect);
                }
            },
            onDisplayUri (uri) {
                config.emitter.emit('message', {
                    type: 'display_uri',
                    data: uri
                });
            }
        }));
} //# sourceMappingURL=metaMask.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/porto.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "porto",
    ()=>porto
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$porto$2f$dist$2f$core$2f$RpcSchema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__RpcSchema$3e$__ = __turbopack_context__.i("[project]/node_modules/porto/dist/core/RpcSchema.js [app-ssr] (ecmascript) <export * as RpcSchema>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$mini$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/mini/index.js [app-ssr] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/promise/withRetry.js [app-ssr] (ecmascript)");
;
;
;
;
function porto(parameters = {}) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((wagmiConfig)=>{
        const chains = wagmiConfig.chains ?? parameters.chains ?? [];
        const transports = (()=>{
            if (wagmiConfig.transports) return wagmiConfig.transports;
            return parameters.transports;
        })();
        let porto_promise;
        let accountsChanged;
        let chainChanged;
        let connect;
        let disconnect;
        return {
            async connect ({ chainId = chains[0].id, ...rest } = {}) {
                const isReconnecting = 'isReconnecting' in rest && rest.isReconnecting || false;
                const withCapabilities = 'withCapabilities' in rest && rest.withCapabilities || false;
                let accounts = [];
                let currentChainId;
                if (isReconnecting) {
                    ;
                    [accounts, currentChainId] = await Promise.all([
                        this.getAccounts().catch(()=>[]),
                        this.getChainId().catch(()=>undefined)
                    ]);
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({
                            chainId
                        }).catch((error)=>{
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw error;
                            return {
                                id: currentChainId
                            };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                }
                const provider = await this.getProvider();
                try {
                    if (!accounts?.length && !isReconnecting) {
                        const res = await provider.request({
                            method: 'wallet_connect',
                            params: [
                                {
                                    ...'capabilities' in rest ? {
                                        capabilities: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$mini$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].encode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$porto$2f$dist$2f$core$2f$RpcSchema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__RpcSchema$3e$__["RpcSchema"].wallet_connect.Capabilities, rest.capabilities ?? {})
                                    } : {},
                                    chainIds: [
                                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId),
                                        ...chains.filter((x)=>x.id !== chainId).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(x.id))
                                    ]
                                }
                            ]
                        });
                        accounts = res.accounts;
                        currentChainId = Number(res.chainIds[0]);
                    }
                    if (!currentChainId) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]();
                    // Manage EIP-1193 event listeners
                    // https://eips.ethereum.org/EIPS/eip-1193#events
                    if (connect) {
                        provider.removeListener('connect', connect);
                        connect = undefined;
                    }
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,
                        // while Connector `accountsChanged` is `string[]`
                        provider.on('accountsChanged', accountsChanged);
                    }
                    if (!chainChanged) {
                        chainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', chainChanged);
                    }
                    if (!disconnect) {
                        disconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', disconnect);
                    }
                    return {
                        accounts: accounts.map((account)=>{
                            if (typeof account === 'object') return withCapabilities ? account : account.address;
                            return withCapabilities ? {
                                address: account,
                                capabilities: {}
                            } : account;
                        }),
                        chainId: currentChainId
                    };
                } catch (err) {
                    const error = err;
                    if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    throw error;
                }
            },
            async disconnect () {
                const provider = await this.getProvider();
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                if (!connect) {
                    connect = this.onConnect.bind(this);
                    provider.on('connect', connect);
                }
                await provider.request({
                    method: 'wallet_disconnect'
                });
            },
            async getAccounts () {
                const provider = await this.getProvider();
                const accounts = await provider.request({
                    method: 'eth_accounts'
                });
                return accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getChainId () {
                const provider = await this.getProvider();
                const hexChainId = await provider.request({
                    method: 'eth_chainId'
                });
                return Number(hexChainId);
            },
            async getPortoInstance () {
                porto_promise ??= (async ()=>{
                    const { Porto } = await __turbopack_context__.A("[project]/node_modules/porto/dist/index.js [app-ssr] (ecmascript, async loader)");
                    return Porto.create({
                        ...parameters,
                        announceProvider: false,
                        chains: chains,
                        transports: transports
                    });
                })();
                return await porto_promise;
            },
            async getProvider () {
                return (await this.getPortoInstance()).provider;
            },
            icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K',
            id: 'xyz.ithaca.porto',
            async isAuthorized () {
                try {
                    // Use retry strategy as some injected wallets (e.g. MetaMask) fail to
                    // immediately resolve JSON-RPC requests on page load.
                    const accounts = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withRetry"])(()=>this.getAccounts());
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            name: 'Porto',
            async onAccountsChanged (accounts) {
                wagmiConfig.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                wagmiConfig.emitter.emit('change', {
                    chainId
                });
            },
            async onConnect (connectInfo) {
                const accounts = await this.getAccounts();
                if (accounts.length === 0) return;
                const chainId = Number(connectInfo.chainId);
                wagmiConfig.emitter.emit('connect', {
                    accounts,
                    chainId
                });
                // Manage EIP-1193 event listeners
                const provider = await this.getProvider();
                if (provider) {
                    if (connect) {
                        provider.removeListener('connect', connect);
                        connect = undefined;
                    }
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,
                        // while Connector `accountsChanged` is `string[]`
                        provider.on('accountsChanged', accountsChanged);
                    }
                    if (!chainChanged) {
                        chainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', chainChanged);
                    }
                    if (!disconnect) {
                        disconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', disconnect);
                    }
                }
            },
            async onDisconnect (_error) {
                const provider = await this.getProvider();
                wagmiConfig.emitter.emit('disconnect');
                // Manage EIP-1193 event listeners
                if (provider) {
                    if (chainChanged) {
                        provider.removeListener('chainChanged', chainChanged);
                        chainChanged = undefined;
                    }
                    if (disconnect) {
                        provider.removeListener('disconnect', disconnect);
                        disconnect = undefined;
                    }
                    if (!connect) {
                        connect = this.onConnect.bind(this);
                        provider.on('connect', connect);
                    }
                }
            },
            async setup () {
                if (!connect) {
                    const provider = await this.getProvider();
                    connect = this.onConnect.bind(this);
                    provider.on('connect', connect);
                }
            },
            async switchChain ({ chainId }) {
                const chain = chains.find((x)=>x.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                const provider = await this.getProvider();
                await provider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [
                        {
                            chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId)
                        }
                    ]
                });
                return chain;
            },
            type: 'injected'
        };
    });
} //# sourceMappingURL=porto.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/safe.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "safe",
    ()=>safe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/connector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
;
;
safe.type = 'safe';
function safe(parameters = {}) {
    const { shimDisconnect = false } = parameters;
    let provider_;
    let disconnect;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'safe',
            name: 'Safe',
            type: safe.type,
            async connect ({ withCapabilities } = {}) {
                const provider = await this.getProvider();
                if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ProviderNotFoundError"]();
                const accounts = await this.getAccounts();
                const chainId = await this.getChainId();
                if (!disconnect) {
                    disconnect = this.onDisconnect.bind(this);
                    provider.on('disconnect', disconnect);
                }
                // Remove disconnected shim if it exists
                if (shimDisconnect) await config.storage?.removeItem('safe.disconnected');
                return {
                    // TODO(v3): Make `withCapabilities: true` default behavior
                    accounts: withCapabilities ? accounts.map((address)=>({
                            address,
                            capabilities: {}
                        })) : accounts,
                    chainId
                };
            },
            async disconnect () {
                const provider = await this.getProvider();
                if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ProviderNotFoundError"]();
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                // Add shim signalling connector is disconnected
                if (shimDisconnect) await config.storage?.setItem('safe.disconnected', true);
            },
            async getAccounts () {
                const provider = await this.getProvider();
                if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ProviderNotFoundError"]();
                return (await provider.request({
                    method: 'eth_accounts'
                })).map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"]);
            },
            async getProvider () {
                // Only allowed in iframe context
                const isIframe = ("TURBOPACK compile-time value", "undefined") !== 'undefined' && window?.parent !== window;
                if ("TURBOPACK compile-time truthy", 1) return;
                //TURBOPACK unreachable
                ;
            },
            async getChainId () {
                const provider = await this.getProvider();
                if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ProviderNotFoundError"]();
                return Number(provider.chainId);
            },
            async isAuthorized () {
                try {
                    const isDisconnected = shimDisconnect && await config.storage?.getItem('safe.disconnected');
                    if (isDisconnected) return false;
                    const accounts = await this.getAccounts();
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            onAccountsChanged () {
            // Not relevant for Safe because changing account requires app reload.
            },
            onChainChanged () {
            // Not relevant for Safe because Safe smart contract wallets only exist on single chain.
            },
            onDisconnect () {
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=safe.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/version.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "version",
    ()=>version
]);
const version = '6.1.3'; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/walletConnect.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "walletConnect",
    ()=>walletConnect
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$extractRpcUrls$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/utils/extractRpcUrls.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/connector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-ssr] (ecmascript)");
;
;
walletConnect.type = 'walletConnect';
function walletConnect(parameters) {
    const isNewChainsStale = parameters.isNewChainsStale ?? true;
    let provider_;
    let providerPromise;
    const NAMESPACE = 'eip155';
    let accountsChanged;
    let chainChanged;
    let connect;
    let displayUri;
    let sessionDelete;
    let disconnect;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'walletConnect',
            name: 'WalletConnect',
            type: walletConnect.type,
            async setup () {
                const provider = await this.getProvider().catch(()=>null);
                if (!provider) return;
                if (!connect) {
                    connect = this.onConnect.bind(this);
                    provider.on('connect', connect);
                }
                if (!sessionDelete) {
                    sessionDelete = this.onSessionDelete.bind(this);
                    provider.on('session_delete', sessionDelete);
                }
            },
            async connect ({ chainId, withCapabilities, ...rest } = {}) {
                try {
                    const provider = await this.getProvider();
                    if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ProviderNotFoundError"]();
                    if (!displayUri) {
                        displayUri = this.onDisplayUri;
                        provider.on('display_uri', displayUri);
                    }
                    let targetChainId = chainId;
                    if (!targetChainId) {
                        const state = await config.storage?.getItem('state') ?? {};
                        const isChainSupported = config.chains.some((x)=>x.id === state.chainId);
                        if (isChainSupported) targetChainId = state.chainId;
                        else targetChainId = config.chains[0]?.id;
                    }
                    if (!targetChainId) throw new Error('No chains found on connector.');
                    const isChainsStale = await this.isChainsStale();
                    // If there is an active session with stale chains, disconnect current session.
                    if (provider.session && isChainsStale) await provider.disconnect();
                    // If there isn't an active session or chains are stale, connect.
                    if (!provider.session || isChainsStale) {
                        const optionalChains = config.chains.filter((chain)=>chain.id !== targetChainId).map((optionalChain)=>optionalChain.id);
                        await provider.connect({
                            optionalChains: [
                                targetChainId,
                                ...optionalChains
                            ],
                            ...'pairingTopic' in rest ? {
                                pairingTopic: rest.pairingTopic
                            } : {}
                        });
                        this.setRequestedChainsIds(config.chains.map((x)=>x.id));
                    }
                    // If session exists and chains are authorized, enable provider for required chain
                    const accounts = (await provider.enable()).map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
                    // Switch to chain if provided
                    let currentChainId = await this.getChainId();
                    if (chainId && currentChainId !== chainId) {
                        const chain = await this.switchChain({
                            chainId
                        }).catch((error)=>{
                            if (error.code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].code && error.cause?.message !== 'Missing or invalid. request() method: wallet_addEthereumChain') throw error;
                            return {
                                id: currentChainId
                            };
                        });
                        currentChainId = chain?.id ?? currentChainId;
                    }
                    if (displayUri) {
                        provider.removeListener('display_uri', displayUri);
                        displayUri = undefined;
                    }
                    if (connect) {
                        provider.removeListener('connect', connect);
                        connect = undefined;
                    }
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', accountsChanged);
                    }
                    if (!chainChanged) {
                        chainChanged = this.onChainChanged.bind(this);
                        provider.on('chainChanged', chainChanged);
                    }
                    if (!disconnect) {
                        disconnect = this.onDisconnect.bind(this);
                        provider.on('disconnect', disconnect);
                    }
                    if (!sessionDelete) {
                        sessionDelete = this.onSessionDelete.bind(this);
                        provider.on('session_delete', sessionDelete);
                    }
                    return {
                        accounts: withCapabilities ? accounts.map((address)=>({
                                address,
                                capabilities: {}
                            })) : accounts,
                        chainId: currentChainId
                    };
                } catch (error) {
                    if (/(user rejected|connection request reset)/i.test(error?.message)) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    }
                    throw error;
                }
            },
            async disconnect () {
                const provider = await this.getProvider();
                try {
                    await provider?.disconnect();
                } catch (error) {
                    if (!/No matching key/i.test(error.message)) throw error;
                } finally{
                    if (chainChanged) {
                        provider?.removeListener('chainChanged', chainChanged);
                        chainChanged = undefined;
                    }
                    if (disconnect) {
                        provider?.removeListener('disconnect', disconnect);
                        disconnect = undefined;
                    }
                    if (!connect) {
                        connect = this.onConnect.bind(this);
                        provider?.on('connect', connect);
                    }
                    if (accountsChanged) {
                        provider?.removeListener('accountsChanged', accountsChanged);
                        accountsChanged = undefined;
                    }
                    if (sessionDelete) {
                        provider?.removeListener('session_delete', sessionDelete);
                        sessionDelete = undefined;
                    }
                    this.setRequestedChainsIds([]);
                }
            },
            async getAccounts () {
                const provider = await this.getProvider();
                return provider.accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getProvider ({ chainId } = {}) {
                async function initProvider() {
                    const optionalChains = config.chains.map((x)=>x.id);
                    if (!optionalChains.length) return;
                    const { EthereumProvider } = await __turbopack_context__.A("[project]/node_modules/@walletconnect/ethereum-provider/dist/index.es.js [app-ssr] (ecmascript, async loader)");
                    return await EthereumProvider.init({
                        ...parameters,
                        disableProviderPing: true,
                        optionalChains,
                        projectId: parameters.projectId,
                        rpcMap: Object.fromEntries(config.chains.map((chain)=>{
                            const [url] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$utils$2f$extractRpcUrls$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractRpcUrls"])({
                                chain,
                                transports: config.transports
                            });
                            return [
                                chain.id,
                                url
                            ];
                        })),
                        showQrModal: parameters.showQrModal ?? true
                    });
                }
                if (!provider_) {
                    if (!providerPromise) providerPromise = initProvider();
                    provider_ = await providerPromise;
                    provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY);
                }
                if (chainId) await this.switchChain?.({
                    chainId
                });
                return provider_;
            },
            async getChainId () {
                const provider = await this.getProvider();
                return provider.chainId;
            },
            async isAuthorized () {
                try {
                    const [accounts, provider] = await Promise.all([
                        this.getAccounts(),
                        this.getProvider()
                    ]);
                    // If an account does not exist on the session, then the connector is unauthorized.
                    if (!accounts.length) return false;
                    // If the chains are stale on the session, then the connector is unauthorized.
                    const isChainsStale = await this.isChainsStale();
                    if (isChainsStale && provider.session) {
                        await provider.disconnect().catch(()=>{});
                        return false;
                    }
                    return true;
                } catch  {
                    return false;
                }
            },
            async switchChain ({ addEthereumChainParameter, chainId }) {
                const provider = await this.getProvider();
                if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$connector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ProviderNotFoundError"]();
                const chain = config.chains.find((x)=>x.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                try {
                    await Promise.all([
                        new Promise((resolve)=>{
                            const listener = ({ chainId: currentChainId })=>{
                                if (currentChainId === chainId) {
                                    config.emitter.off('change', listener);
                                    resolve();
                                }
                            };
                            config.emitter.on('change', listener);
                        }),
                        provider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [
                                {
                                    chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId)
                                }
                            ]
                        })
                    ]);
                    const requestedChains = await this.getRequestedChainsIds();
                    this.setRequestedChainsIds([
                        ...requestedChains,
                        chainId
                    ]);
                    return chain;
                } catch (err) {
                    const error = err;
                    if (/(user rejected)/i.test(error.message)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    // Indicates chain is not added to provider
                    try {
                        let blockExplorerUrls;
                        if (addEthereumChainParameter?.blockExplorerUrls) blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
                        else blockExplorerUrls = chain.blockExplorers?.default.url ? [
                            chain.blockExplorers?.default.url
                        ] : [];
                        let rpcUrls;
                        if (addEthereumChainParameter?.rpcUrls?.length) rpcUrls = addEthereumChainParameter.rpcUrls;
                        else rpcUrls = [
                            ...chain.rpcUrls.default.http
                        ];
                        const addEthereumChain = {
                            blockExplorerUrls,
                            chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId),
                            chainName: addEthereumChainParameter?.chainName ?? chain.name,
                            iconUrls: addEthereumChainParameter?.iconUrls,
                            nativeCurrency: addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,
                            rpcUrls
                        };
                        await provider.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                addEthereumChain
                            ]
                        });
                        const requestedChains = await this.getRequestedChainsIds();
                        this.setRequestedChainsIds([
                            ...requestedChains,
                            chainId
                        ]);
                        return chain;
                    } catch (error) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
                    }
                }
            },
            onAccountsChanged (accounts) {
                if (accounts.length === 0) this.onDisconnect();
                else config.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onConnect (connectInfo) {
                const chainId = Number(connectInfo.chainId);
                const accounts = await this.getAccounts();
                config.emitter.emit('connect', {
                    accounts,
                    chainId
                });
            },
            async onDisconnect (_error) {
                this.setRequestedChainsIds([]);
                config.emitter.emit('disconnect');
                const provider = await this.getProvider();
                if (accountsChanged) {
                    provider.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                if (chainChanged) {
                    provider.removeListener('chainChanged', chainChanged);
                    chainChanged = undefined;
                }
                if (disconnect) {
                    provider.removeListener('disconnect', disconnect);
                    disconnect = undefined;
                }
                if (sessionDelete) {
                    provider.removeListener('session_delete', sessionDelete);
                    sessionDelete = undefined;
                }
                if (!connect) {
                    connect = this.onConnect.bind(this);
                    provider.on('connect', connect);
                }
            },
            onDisplayUri (uri) {
                config.emitter.emit('message', {
                    type: 'display_uri',
                    data: uri
                });
            },
            onSessionDelete () {
                this.onDisconnect();
            },
            getNamespaceChainsIds () {
                if (!provider_) return [];
                const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map((account)=>Number.parseInt(account.split(':')[1] || '', 10));
                return chainIds ?? [];
            },
            async getRequestedChainsIds () {
                return await config.storage?.getItem(this.requestedChainsStorageKey) ?? [];
            },
            /**
         * Checks if the target chains match the chains that were
         * initially requested by the connector for the WalletConnect session.
         * If there is a mismatch, this means that the chains on the connector
         * are considered stale, and need to be revalidated at a later point (via
         * connection).
         *
         * There may be a scenario where a dapp adds a chain to the
         * connector later on, however, this chain will not have been approved or rejected
         * by the wallet. In this case, the chain is considered stale.
         */ async isChainsStale () {
                if (!isNewChainsStale) return false;
                const connectorChains = config.chains.map((x)=>x.id);
                const namespaceChains = this.getNamespaceChainsIds();
                if (namespaceChains.length && !namespaceChains.some((id)=>connectorChains.includes(id))) return false;
                const requestedChains = await this.getRequestedChainsIds();
                return !connectorChains.every((id)=>requestedChains.includes(id));
            },
            async setRequestedChainsIds (chains) {
                await config.storage?.setItem(this.requestedChainsStorageKey, chains);
            },
            get requestedChainsStorageKey () {
                return `${this.id}.requestedChains`;
            }
        }));
} //# sourceMappingURL=walletConnect.js.map
}),
"[project]/node_modules/@wagmi/connectors/dist/esm/exports/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "baseAccount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$baseAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["baseAccount"],
    "coinbaseWallet",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$coinbaseWallet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coinbaseWallet"],
    "gemini",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$gemini$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gemini"],
    "injected",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$injected$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["injected"],
    "metaMask",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$metaMask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["metaMask"],
    "mock",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$mock$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mock"],
    "porto",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$porto$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["porto"],
    "safe",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$safe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safe"],
    "version",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"],
    "walletConnect",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$walletConnect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["walletConnect"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$exports$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/exports/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$injected$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/injected.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$mock$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/mock.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$baseAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/baseAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$coinbaseWallet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$gemini$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/gemini.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$metaMask$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/metaMask.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$porto$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/porto.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$safe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/safe.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/version.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$esm$2f$walletConnect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/esm/walletConnect.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/viem/_esm/utils/rpc/socket.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getSocketRpcClient",
    ()=>getSocketRpcClient,
    "socketClientCache",
    ()=>socketClientCache
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/request.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$createBatchScheduler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/promise/createBatchScheduler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withTimeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/promise/withTimeout.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/rpc/id.js [app-ssr] (ecmascript)");
;
;
;
;
const socketClientCache = /*#__PURE__*/ new Map();
async function getSocketRpcClient(parameters) {
    const { getSocket, keepAlive = true, key = 'socket', reconnect = true, url } = parameters;
    const { interval: keepAliveInterval = 30_000 } = typeof keepAlive === 'object' ? keepAlive : {};
    const { attempts = 5, delay = 2_000 } = typeof reconnect === 'object' ? reconnect : {};
    const id = JSON.stringify({
        keepAlive,
        key,
        url,
        reconnect
    });
    let socketClient = socketClientCache.get(id);
    // If the socket already exists, return it.
    if (socketClient) return socketClient;
    let reconnectCount = 0;
    const { schedule } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$createBatchScheduler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBatchScheduler"])({
        id,
        fn: async ()=>{
            // Set up a cache for incoming "synchronous" requests.
            const requests = new Map();
            // Set up a cache for subscriptions (eth_subscribe).
            const subscriptions = new Map();
            let error;
            let socket;
            let keepAliveTimer;
            let reconnectInProgress = false;
            function attemptReconnect() {
                // Attempt to reconnect.
                if (reconnect && reconnectCount < attempts) {
                    if (reconnectInProgress) return;
                    reconnectInProgress = true;
                    reconnectCount++;
                    // Make sure the previous socket is definitely closed.
                    socket?.close();
                    setTimeout(async ()=>{
                        // biome-ignore lint/suspicious/noConsole: _
                        await setup().catch(console.error);
                        reconnectInProgress = false;
                    }, delay);
                } else {
                    requests.clear();
                    subscriptions.clear();
                }
            }
            // Set up socket implementation.
            async function setup() {
                const result = await getSocket({
                    onClose () {
                        // Notify all requests and subscriptions of the closure error.
                        for (const request of requests.values())request.onError?.(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SocketClosedError"]({
                            url
                        }));
                        for (const subscription of subscriptions.values())subscription.onError?.(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SocketClosedError"]({
                            url
                        }));
                        attemptReconnect();
                    },
                    onError (error_) {
                        error = error_;
                        // Notify all requests and subscriptions of the error.
                        for (const request of requests.values())request.onError?.(error);
                        for (const subscription of subscriptions.values())subscription.onError?.(error);
                        attemptReconnect();
                    },
                    onOpen () {
                        error = undefined;
                        reconnectCount = 0;
                    },
                    onResponse (data) {
                        const isSubscription = data.method === 'eth_subscription';
                        const id = isSubscription ? data.params.subscription : data.id;
                        const cache = isSubscription ? subscriptions : requests;
                        const callback = cache.get(id);
                        if (callback) callback.onResponse(data);
                        if (!isSubscription) cache.delete(id);
                    }
                });
                socket = result;
                if (keepAlive) {
                    if (keepAliveTimer) clearInterval(keepAliveTimer);
                    keepAliveTimer = setInterval(()=>socket.ping?.(), keepAliveInterval);
                }
                if (reconnect && subscriptions.size > 0) {
                    const subscriptionEntries = subscriptions.entries();
                    for (const [key, { onResponse, body, onError }] of subscriptionEntries){
                        if (!body) continue;
                        subscriptions.delete(key);
                        socketClient?.request({
                            body,
                            onResponse,
                            onError
                        });
                    }
                }
                return result;
            }
            await setup();
            error = undefined;
            // Create a new socket instance.
            socketClient = {
                close () {
                    keepAliveTimer && clearInterval(keepAliveTimer);
                    socket.close();
                    socketClientCache.delete(id);
                },
                get socket () {
                    return socket;
                },
                request ({ body, onError, onResponse }) {
                    if (error && onError) onError(error);
                    const id = body.id ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["idCache"].take();
                    const callback = (response)=>{
                        if (typeof response.id === 'number' && id !== response.id) return;
                        // If we are subscribing to a topic, we want to set up a listener for incoming
                        // messages.
                        if (body.method === 'eth_subscribe' && typeof response.result === 'string') subscriptions.set(response.result, {
                            onResponse: callback,
                            onError,
                            body
                        });
                        // If we are unsubscribing from a topic, we want to remove the listener.
                        if (body.method === 'eth_unsubscribe') subscriptions.delete(body.params?.[0]);
                        onResponse(response);
                    };
                    requests.set(id, {
                        onResponse: callback,
                        onError
                    });
                    try {
                        socket.request({
                            body: {
                                jsonrpc: '2.0',
                                id,
                                ...body
                            }
                        });
                    } catch (error) {
                        onError?.(error);
                    }
                },
                requestAsync ({ body, timeout = 10_000 }) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withTimeout$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withTimeout"])(()=>new Promise((onResponse, onError)=>this.request({
                                body,
                                onError,
                                onResponse
                            })), {
                        errorInstance: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TimeoutError"]({
                            body,
                            url
                        }),
                        timeout
                    });
                },
                requests,
                subscriptions,
                url
            };
            socketClientCache.set(id, socketClient);
            return [
                socketClient
            ];
        }
    });
    const [_, [socketClient_]] = await schedule();
    return socketClient_;
} //# sourceMappingURL=socket.js.map
}),
"[project]/node_modules/viem/_esm/utils/rpc/webSocket.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getWebSocketRpcClient",
    ()=>getWebSocketRpcClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/request.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/rpc/socket.js [app-ssr] (ecmascript)");
;
;
async function getWebSocketRpcClient(url, options = {}) {
    const { keepAlive, reconnect } = options;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$socket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSocketRpcClient"])({
        async getSocket ({ onClose, onError, onOpen, onResponse }) {
            const WebSocket = await __turbopack_context__.A("[project]/node_modules/isows/_esm/index.js [app-ssr] (ecmascript, async loader)").then((module)=>module.WebSocket);
            const socket = new WebSocket(url);
            function onClose_() {
                socket.removeEventListener('close', onClose_);
                socket.removeEventListener('message', onMessage);
                socket.removeEventListener('error', onError);
                socket.removeEventListener('open', onOpen);
                onClose();
            }
            function onMessage({ data }) {
                // ignore empty messages
                if (typeof data === 'string' && data.trim().length === 0) return;
                try {
                    const _data = JSON.parse(data);
                    onResponse(_data);
                } catch (error) {
                    onError(error);
                }
            }
            // Setup event listeners for RPC & subscription responses.
            socket.addEventListener('close', onClose_);
            socket.addEventListener('message', onMessage);
            socket.addEventListener('error', onError);
            socket.addEventListener('open', onOpen);
            // Wait for the socket to open.
            if (socket.readyState === WebSocket.CONNECTING) {
                await new Promise((resolve, reject)=>{
                    if (!socket) return;
                    socket.onopen = resolve;
                    socket.onerror = reject;
                });
            }
            const { close: close_ } = socket;
            return Object.assign(socket, {
                close () {
                    close_.bind(socket)();
                    onClose_();
                },
                ping () {
                    try {
                        if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebSocketRequestError"]({
                            url: socket.url,
                            cause: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SocketClosedError"]({
                                url: socket.url
                            })
                        });
                        const body = {
                            jsonrpc: '2.0',
                            id: null,
                            method: 'net_version',
                            params: []
                        };
                        socket.send(JSON.stringify(body));
                    } catch (error) {
                        onError(error);
                    }
                },
                request ({ body }) {
                    if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WebSocketRequestError"]({
                        body,
                        url: socket.url,
                        cause: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SocketClosedError"]({
                            url: socket.url
                        })
                    });
                    return socket.send(JSON.stringify(body));
                }
            });
        },
        keepAlive,
        reconnect,
        url
    });
} //# sourceMappingURL=webSocket.js.map
}),
"[project]/node_modules/viem/_esm/utils/rpc/compat.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// TODO(v3): This file is here for backwards compatibility, and to prevent breaking changes.
// These APIs will be removed in v3.
__turbopack_context__.s([
    "getSocket",
    ()=>getSocket,
    "rpc",
    ()=>rpc
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/rpc/http.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$webSocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/rpc/webSocket.js [app-ssr] (ecmascript)");
;
;
function webSocket(socketClient, { body, onError, onResponse }) {
    socketClient.request({
        body,
        onError,
        onResponse
    });
    return socketClient;
}
async function webSocketAsync(socketClient, { body, timeout = 10_000 }) {
    return socketClient.requestAsync({
        body,
        timeout
    });
}
async function getSocket(url) {
    const client = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$webSocket$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getWebSocketRpcClient"])(url);
    return Object.assign(client.socket, {
        requests: client.requests,
        subscriptions: client.subscriptions
    });
}
const rpc = {
    /**
     * @deprecated use `getHttpRpcClient` instead.
     *
     * ```diff
     * -import { rpc } from 'viem/utils'
     * +import { getHttpRpcClient } from 'viem/utils'
     *
     * -rpc.http(url, params)
     * +const httpClient = getHttpRpcClient(url)
     * +httpClient.request(params)
     * ```
     */ http (url, params) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getHttpRpcClient"])(url).request(params);
    },
    /**
     * @deprecated use `getWebSocketRpcClient` instead.
     *
     * ```diff
     * -import { rpc } from 'viem/utils'
     * +import { getWebSocketRpcClient } from 'viem/utils'
     *
     * -rpc.webSocket(url, params)
     * +const webSocketClient = getWebSocketRpcClient(url)
     * +webSocketClient.request(params)
     * ```
     */ webSocket,
    /**
     * @deprecated use `getWebSocketRpcClient` instead.
     *
     * ```diff
     * -import { rpc } from 'viem/utils'
     * +import { getWebSocketRpcClient } from 'viem/utils'
     *
     * -const response = await rpc.webSocketAsync(url, params)
     * +const webSocketClient = getWebSocketRpcClient(url)
     * +const response = await webSocketClient.requestAsync(params)
     * ```
     */ webSocketAsync
}; /* c8 ignore end */  //# sourceMappingURL=compat.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/arbitrum.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "arbitrum",
    ()=>arbitrum
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
const arbitrum = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    id: 42_161,
    name: 'Arbitrum One',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18
    },
    blockTime: 250,
    rpcUrls: {
        default: {
            http: [
                'https://arb1.arbitrum.io/rpc'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Arbiscan',
            url: 'https://arbiscan.io',
            apiUrl: 'https://api.arbiscan.io/api'
        }
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 7654707
        }
    }
}); //# sourceMappingURL=arbitrum.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "arbitrumSepolia",
    ()=>arbitrumSepolia
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
const arbitrumSepolia = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    id: 421_614,
    name: 'Arbitrum Sepolia',
    blockTime: 250,
    nativeCurrency: {
        name: 'Arbitrum Sepolia Ether',
        symbol: 'ETH',
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                'https://sepolia-rollup.arbitrum.io/rpc'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Arbiscan',
            url: 'https://sepolia.arbiscan.io',
            apiUrl: 'https://api-sepolia.arbiscan.io/api'
        }
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 81930
        }
    },
    testnet: true
}); //# sourceMappingURL=arbitrumSepolia.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/baseSepolia.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "baseSepolia",
    ()=>baseSepolia,
    "baseSepoliaPreconf",
    ()=>baseSepoliaPreconf
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/op-stack/chainConfig.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
;
const sourceId = 11_155_111; // sepolia
const baseSepolia = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["chainConfig"],
    id: 84532,
    network: 'base-sepolia',
    name: 'Base Sepolia',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                'https://sepolia.base.org'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Basescan',
            url: 'https://sepolia.basescan.org',
            apiUrl: 'https://api-sepolia.basescan.org/api'
        }
    },
    contracts: {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["chainConfig"].contracts,
        disputeGameFactory: {
            [sourceId]: {
                address: '0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1'
            }
        },
        l2OutputOracle: {
            [sourceId]: {
                address: '0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254'
            }
        },
        portal: {
            [sourceId]: {
                address: '0x49f53e41452c74589e85ca1677426ba426459e85',
                blockCreated: 4446677
            }
        },
        l1StandardBridge: {
            [sourceId]: {
                address: '0xfd0Bf71F60660E2f608ed56e1659C450eB113120',
                blockCreated: 4446677
            }
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 1059647
        }
    },
    testnet: true,
    sourceId
});
const baseSepoliaPreconf = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    ...baseSepolia,
    experimental_preconfirmationTime: 200,
    rpcUrls: {
        default: {
            http: [
                'https://sepolia-preconf.base.org'
            ]
        }
    }
}); //# sourceMappingURL=baseSepolia.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/mainnet.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "mainnet",
    ()=>mainnet
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
const mainnet = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    id: 1,
    name: 'Ethereum',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18
    },
    blockTime: 12_000,
    rpcUrls: {
        default: {
            http: [
                'https://eth.merkle.io'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Etherscan',
            url: 'https://etherscan.io',
            apiUrl: 'https://api.etherscan.io/api'
        }
    },
    contracts: {
        ensUniversalResolver: {
            address: '0xeeeeeeee14d718c2b47d9923deab1335e144eeee',
            blockCreated: 23_085_558
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 14_353_601
        }
    }
}); //# sourceMappingURL=mainnet.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/optimism.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "optimism",
    ()=>optimism
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/op-stack/chainConfig.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
;
const sourceId = 1; // mainnet
const optimism = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["chainConfig"],
    id: 10,
    name: 'OP Mainnet',
    nativeCurrency: {
        name: 'Ether',
        symbol: 'ETH',
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                'https://mainnet.optimism.io'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Optimism Explorer',
            url: 'https://optimistic.etherscan.io',
            apiUrl: 'https://api-optimistic.etherscan.io/api'
        }
    },
    contracts: {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["chainConfig"].contracts,
        disputeGameFactory: {
            [sourceId]: {
                address: '0xe5965Ab5962eDc7477C8520243A95517CD252fA9'
            }
        },
        l2OutputOracle: {
            [sourceId]: {
                address: '0xdfe97868233d1aa22e815a266982f2cf17685a27'
            }
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 4286263
        },
        portal: {
            [sourceId]: {
                address: '0xbEb5Fc579115071764c7423A4f12eDde41f106Ed'
            }
        },
        l1StandardBridge: {
            [sourceId]: {
                address: '0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1'
            }
        }
    },
    sourceId
}); //# sourceMappingURL=optimism.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/optimismSepolia.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "optimismSepolia",
    ()=>optimismSepolia
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/op-stack/chainConfig.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
;
const sourceId = 11_155_111; // sepolia
const optimismSepolia = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["chainConfig"],
    id: 11155420,
    name: 'OP Sepolia',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                'https://sepolia.optimism.io'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Blockscout',
            url: 'https://optimism-sepolia.blockscout.com',
            apiUrl: 'https://optimism-sepolia.blockscout.com/api'
        }
    },
    contracts: {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$op$2d$stack$2f$chainConfig$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["chainConfig"].contracts,
        disputeGameFactory: {
            [sourceId]: {
                address: '0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1'
            }
        },
        l2OutputOracle: {
            [sourceId]: {
                address: '0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F'
            }
        },
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 1620204
        },
        portal: {
            [sourceId]: {
                address: '0x16Fc5058F25648194471939df75CF27A2fdC48BC'
            }
        },
        l1StandardBridge: {
            [sourceId]: {
                address: '0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1'
            }
        }
    },
    testnet: true,
    sourceId
}); //# sourceMappingURL=optimismSepolia.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/polygon.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "polygon",
    ()=>polygon
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
const polygon = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    id: 137,
    name: 'Polygon',
    blockTime: 2000,
    nativeCurrency: {
        name: 'POL',
        symbol: 'POL',
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                'https://polygon-rpc.com'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'PolygonScan',
            url: 'https://polygonscan.com',
            apiUrl: 'https://api.polygonscan.com/api'
        }
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 25770160
        }
    }
}); //# sourceMappingURL=polygon.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/polygonAmoy.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "polygonAmoy",
    ()=>polygonAmoy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
const polygonAmoy = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    id: 80_002,
    name: 'Polygon Amoy',
    nativeCurrency: {
        name: 'POL',
        symbol: 'POL',
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                'https://rpc-amoy.polygon.technology'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'PolygonScan',
            url: 'https://amoy.polygonscan.com',
            apiUrl: 'https://api-amoy.polygonscan.com/api'
        }
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 3127388
        }
    },
    testnet: true
}); //# sourceMappingURL=polygonAmoy.js.map
}),
"[project]/node_modules/viem/_esm/chains/definitions/sepolia.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sepolia",
    ()=>sepolia
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
;
const sepolia = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
    id: 11_155_111,
    name: 'Sepolia',
    nativeCurrency: {
        name: 'Sepolia Ether',
        symbol: 'ETH',
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                'https://11155111.rpc.thirdweb.com'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Etherscan',
            url: 'https://sepolia.etherscan.io',
            apiUrl: 'https://api-sepolia.etherscan.io/api'
        }
    },
    contracts: {
        multicall3: {
            address: '0xca11bde05977b3631167028862be2a173976ca11',
            blockCreated: 751532
        },
        ensUniversalResolver: {
            address: '0xeeeeeeee14d718c2b47d9923deab1335e144eeee',
            blockCreated: 8_928_790
        }
    },
    testnet: true
}); //# sourceMappingURL=sepolia.js.map
}),
"[project]/node_modules/viem/_esm/utils/abi/encodePacked.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "encodePacked",
    ()=>encodePacked
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$abi$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/abi.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/address.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/isAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/pad.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/regex.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
function encodePacked(types, values) {
    if (types.length !== values.length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$abi$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbiEncodingLengthMismatchError"]({
        expectedLength: types.length,
        givenLength: values.length
    });
    const data = [];
    for(let i = 0; i < types.length; i++){
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concatHex"])(data);
}
function encode(type, value, isArray = false) {
    if (type === 'address') {
        const address = value;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAddress"])(address)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidAddressError"]({
            address
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pad"])(address.toLowerCase(), {
            size: isArray ? 32 : null
        });
    }
    if (type === 'string') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringToHex"])(value);
    if (type === 'bytes') return value;
    if (type === 'bool') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["boolToHex"])(value), {
        size: isArray ? 32 : 1
    });
    const intMatch = type.match(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["integerRegex"]);
    if (intMatch) {
        const [_type, baseType, bits = '256'] = intMatch;
        const size = Number.parseInt(bits, 10) / 8;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(value, {
            size: isArray ? 32 : size,
            signed: baseType === 'int'
        });
    }
    const bytesMatch = type.match(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesRegex"]);
    if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (Number.parseInt(size, 10) !== (value.length - 2) / 2) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$abi$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BytesSizeMismatchError"]({
            expectedSize: Number.parseInt(size, 10),
            givenSize: (value.length - 2) / 2
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pad"])(value, {
            dir: 'right',
            size: isArray ? 32 : null
        });
    }
    const arrayMatch = type.match(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayRegex"]);
    if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for(let i = 0; i < value.length; i++){
            data.push(encode(childType, value[i], true));
        }
        if (data.length === 0) return '0x';
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concatHex"])(data);
    }
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$abi$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsupportedPackedAbiType"](type);
} //# sourceMappingURL=encodePacked.js.map
}),
"[project]/node_modules/viem/_esm/utils/data/isBytes.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isBytes",
    ()=>isBytes
]);
function isBytes(value) {
    if (!value) return false;
    if (typeof value !== 'object') return false;
    if (!('BYTES_PER_ELEMENT' in value)) return false;
    return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array';
} //# sourceMappingURL=isBytes.js.map
}),
"[project]/node_modules/viem/_esm/utils/address/getContractAddress.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getContractAddress",
    ()=>getContractAddress,
    "getCreate2Address",
    ()=>getCreate2Address,
    "getCreateAddress",
    ()=>getCreateAddress
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/concat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/isBytes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/pad.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$slice$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/slice.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toBytes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toRlp$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toRlp.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
function getContractAddress(opts) {
    if (opts.opcode === 'CREATE2') return getCreate2Address(opts);
    return getCreateAddress(opts);
}
function getCreateAddress(opts) {
    const from = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBytes"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(opts.from));
    let nonce = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBytes"])(opts.nonce);
    if (nonce[0] === 0) nonce = new Uint8Array([]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(`0x${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toRlp$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRlp"])([
        from,
        nonce
    ], 'bytes')).slice(26)}`);
}
function getCreate2Address(opts) {
    const from = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBytes"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(opts.from));
    const salt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pad"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBytes"])(opts.salt) ? opts.salt : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBytes"])(opts.salt), {
        size: 32
    });
    const bytecodeHash = (()=>{
        if ('bytecodeHash' in opts) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBytes"])(opts.bytecodeHash)) return opts.bytecodeHash;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBytes"])(opts.bytecodeHash);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])(opts.bytecode, 'bytes');
    })();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$slice$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["slice"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBytes"])('0xff'),
        from,
        salt,
        bytecodeHash
    ])), 12));
} //# sourceMappingURL=getContractAddress.js.map
}),
"[project]/node_modules/@wagmi/core/dist/esm/connectors/mock.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "mock",
    ()=>mock
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/custom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/fromHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/request.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$compat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/rpc/compat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/esm/connectors/createConnector.js [app-ssr] (ecmascript)");
;
;
;
;
mock.type = 'mock';
function mock(parameters) {
    const transactionCache = new Map();
    const features = parameters.features ?? {
        defaultConnected: false
    };
    let connected = features.defaultConnected;
    let connectedChainId;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$connectors$2f$createConnector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createConnector"])((config)=>({
            id: 'mock',
            name: 'Mock Connector',
            type: mock.type,
            async setup () {
                connectedChainId = config.chains[0].id;
            },
            async connect ({ chainId, withCapabilities } = {}) {
                if (features.connectError) {
                    if (typeof features.connectError === 'boolean') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](new Error('Failed to connect.'));
                    throw features.connectError;
                }
                const provider = await this.getProvider();
                const accounts = await provider.request({
                    method: 'eth_requestAccounts'
                });
                let currentChainId = await this.getChainId();
                if (chainId && currentChainId !== chainId) {
                    const chain = await this.switchChain({
                        chainId
                    });
                    currentChainId = chain.id;
                }
                connected = true;
                return {
                    accounts: withCapabilities ? accounts.map((x)=>({
                            address: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x),
                            capabilities: {
                                foo: {
                                    bar: x
                                }
                            }
                        })) : accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x)),
                    chainId: currentChainId
                };
            },
            async disconnect () {
                connected = false;
            },
            async getAccounts () {
                if (!connected) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ConnectorNotConnectedError"]();
                const provider = await this.getProvider();
                const accounts = await provider.request({
                    method: 'eth_accounts'
                });
                return accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x));
            },
            async getChainId () {
                const provider = await this.getProvider();
                const hexChainId = await provider.request({
                    method: 'eth_chainId'
                });
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(hexChainId, 'number');
            },
            async isAuthorized () {
                if (!features.reconnect) return false;
                if (!connected) return false;
                const accounts = await this.getAccounts();
                return !!accounts.length;
            },
            async switchChain ({ chainId }) {
                const provider = await this.getProvider();
                const chain = config.chains.find((x)=>x.id === chainId);
                if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SwitchChainError"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ChainNotConfiguredError"]());
                await provider.request({
                    method: 'wallet_switchEthereumChain',
                    params: [
                        {
                            chainId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(chainId)
                        }
                    ]
                });
                return chain;
            },
            onAccountsChanged (accounts) {
                if (accounts.length === 0) this.onDisconnect();
                else config.emitter.emit('change', {
                    accounts: accounts.map((x)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAddress"])(x))
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                config.emitter.emit('disconnect');
                connected = false;
            },
            async getProvider ({ chainId } = {}) {
                const chain = config.chains.find((x)=>x.id === chainId) ?? config.chains[0];
                const url = chain.rpcUrls.default.http[0];
                const request = async ({ method, params })=>{
                    // eth methods
                    if (method === 'eth_chainId') return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToHex"])(connectedChainId);
                    if (method === 'eth_requestAccounts') return parameters.accounts;
                    if (method === 'eth_signTypedData_v4') {
                        if (features.signTypedDataError) {
                            if (typeof features.signTypedDataError === 'boolean') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](new Error('Failed to sign typed data.'));
                            throw features.signTypedDataError;
                        }
                    }
                    // wallet methods
                    if (method === 'wallet_switchEthereumChain') {
                        if (features.switchChainError) {
                            if (typeof features.switchChainError === 'boolean') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](new Error('Failed to switch chain.'));
                            throw features.switchChainError;
                        }
                        connectedChainId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromHex"])(params[0].chainId, 'number');
                        this.onChainChanged(connectedChainId.toString());
                        return;
                    }
                    if (method === 'wallet_watchAsset') {
                        if (features.watchAssetError) {
                            if (typeof features.watchAssetError === 'boolean') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](new Error('Failed to switch chain.'));
                            throw features.watchAssetError;
                        }
                        return connected;
                    }
                    if (method === 'wallet_getCapabilities') return {
                        '0x2105': {
                            paymasterService: {
                                supported: params[0] === '0x95132632579b073D12a6673e18Ab05777a6B86f8'
                            },
                            sessionKeys: {
                                supported: true
                            }
                        },
                        '0x14A34': {
                            paymasterService: {
                                supported: params[0] === '0x95132632579b073D12a6673e18Ab05777a6B86f8'
                            }
                        }
                    };
                    if (method === 'wallet_sendCalls') {
                        const hashes = [];
                        const calls = params[0].calls;
                        const from = params[0].from;
                        for (const call of calls){
                            const { result, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$compat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpc"].http(url, {
                                body: {
                                    method: 'eth_sendTransaction',
                                    params: [
                                        {
                                            ...call,
                                            ...typeof from !== 'undefined' ? {
                                                from
                                            } : {}
                                        }
                                    ]
                                }
                            });
                            if (error) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RpcRequestError"]({
                                body: {
                                    method,
                                    params
                                },
                                error,
                                url
                            });
                            hashes.push(result);
                        }
                        const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringToHex"])(JSON.stringify(calls)));
                        transactionCache.set(id, hashes);
                        return {
                            id
                        };
                    }
                    if (method === 'wallet_getCallsStatus') {
                        const hashes = transactionCache.get(params[0]);
                        if (!hashes) return {
                            atomic: false,
                            chainId: '0x1',
                            id: params[0],
                            status: 100,
                            receipts: [],
                            version: '2.0.0'
                        };
                        const receipts = await Promise.all(hashes.map(async (hash)=>{
                            const { result, error } = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$compat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpc"].http(url, {
                                body: {
                                    method: 'eth_getTransactionReceipt',
                                    params: [
                                        hash
                                    ],
                                    id: 0
                                }
                            });
                            if (error) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RpcRequestError"]({
                                body: {
                                    method,
                                    params
                                },
                                error,
                                url
                            });
                            if (!result) return null;
                            return {
                                blockHash: result.blockHash,
                                blockNumber: result.blockNumber,
                                gasUsed: result.gasUsed,
                                logs: result.logs,
                                status: result.status,
                                transactionHash: result.transactionHash
                            };
                        }));
                        const receipts_ = receipts.filter((x)=>x !== null);
                        if (receipts_.length === 0) return {
                            atomic: false,
                            chainId: '0x1',
                            id: params[0],
                            status: 100,
                            receipts: [],
                            version: '2.0.0'
                        };
                        return {
                            atomic: false,
                            chainId: '0x1',
                            id: params[0],
                            status: 200,
                            receipts: receipts_,
                            version: '2.0.0'
                        };
                    }
                    if (method === 'wallet_showCallsStatus') return;
                    // other methods
                    if (method === 'personal_sign') {
                        if (features.signMessageError) {
                            if (typeof features.signMessageError === 'boolean') throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](new Error('Failed to sign message.'));
                            throw features.signMessageError;
                        }
                        // Change `personal_sign` to `eth_sign` and swap params
                        method = 'eth_sign';
                        params = [
                            params[1],
                            params[0]
                        ];
                    }
                    const body = {
                        method,
                        params
                    };
                    const { error, result } = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$rpc$2f$compat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpc"].http(url, {
                        body
                    });
                    if (error) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RpcRequestError"]({
                        body,
                        error,
                        url
                    });
                    return result;
                };
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["custom"])({
                    request
                })({
                    retryCount: 0
                });
            }
        }));
} //# sourceMappingURL=mock.js.map
}),
"[project]/node_modules/@wagmi/core/dist/esm/utils/extractRpcUrls.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extractRpcUrls",
    ()=>extractRpcUrls
]);
function extractRpcUrls(parameters) {
    const { chain } = parameters;
    const fallbackUrl = chain.rpcUrls.default.http[0];
    if (!parameters.transports) return [
        fallbackUrl
    ];
    const transport = parameters.transports?.[chain.id]?.({
        chain
    });
    const transports = transport?.value?.transports || [
        transport
    ];
    return transports.map(({ value })=>value?.url || fallbackUrl);
} //# sourceMappingURL=extractRpcUrls.js.map
}),
"[project]/node_modules/@metamask/utils/dist/misc.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

//
// Types
//
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */ __turbopack_context__.s([
    "ESCAPE_CHARACTERS_REGEXP",
    ()=>ESCAPE_CHARACTERS_REGEXP,
    "JsonSize",
    ()=>JsonSize,
    "calculateNumberSize",
    ()=>calculateNumberSize,
    "calculateStringSize",
    ()=>calculateStringSize,
    "getKnownPropertyNames",
    ()=>getKnownPropertyNames,
    "hasProperty",
    ()=>hasProperty,
    "isASCII",
    ()=>isASCII,
    "isNonEmptyArray",
    ()=>isNonEmptyArray,
    "isNullOrUndefined",
    ()=>isNullOrUndefined,
    "isObject",
    ()=>isObject,
    "isPlainObject",
    ()=>isPlainObject
]);
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
const hasProperty = (objectToCheck, name)=>Object.hasOwnProperty.call(objectToCheck, name);
function getKnownPropertyNames(object) {
    return Object.getOwnPropertyNames(object);
}
var JsonSize;
(function(JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = JsonSize || (JsonSize = {}));
const ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while(Object.getPrototypeOf(proto) !== null){
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    } catch (_) {
        return false;
    }
}
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
function calculateStringSize(value) {
    const size = value.split('').reduce((total, character)=>{
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;
}
function calculateNumberSize(value) {
    return value.toString().length;
} //# sourceMappingURL=misc.mjs.map
}),
"[project]/node_modules/@metamask/utils/dist/errors.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getErrorMessage",
    ()=>getErrorMessage,
    "isErrorWithCode",
    ()=>isErrorWithCode,
    "isErrorWithMessage",
    ()=>isErrorWithMessage,
    "isErrorWithStack",
    ()=>isErrorWithStack,
    "wrapError",
    ()=>wrapError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pony$2d$cause$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/pony-cause/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pony$2d$cause$2f$lib$2f$error$2d$with$2d$cause$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pony-cause/lib/error-with-cause.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/utils/dist/misc.mjs [app-ssr] (ecmascript)");
;
;
/**
 * Type guard for determining whether the given value is an instance of Error.
 * For errors generated via `fs.promises`, `error instanceof Error` won't work,
 * so we have to come up with another way of testing.
 *
 * @param error - The object to check.
 * @returns A boolean.
 */ function isError(error) {
    return error instanceof Error || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(error) && error.constructor.name === 'Error';
}
function isErrorWithCode(error) {
    return typeof error === 'object' && error !== null && 'code' in error;
}
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
function isErrorWithStack(error) {
    return typeof error === 'object' && error !== null && 'stack' in error;
}
function getErrorMessage(error) {
    if (isErrorWithMessage(error) && typeof error.message === 'string') {
        return error.message;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNullOrUndefined"])(error)) {
        return '';
    }
    return String(error);
}
function wrapError(originalError, message) {
    if (isError(originalError)) {
        let error;
        if (Error.length === 2) {
            // for some reason `tsserver` is not complaining that the
            // Error constructor doesn't support a second argument in the editor,
            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            error = new Error(message, {
                cause: originalError
            });
        } else {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pony$2d$cause$2f$lib$2f$error$2d$with$2d$cause$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ErrorWithCause"](message, {
                cause: originalError
            });
        }
        if (isErrorWithCode(originalError)) {
            error.code = originalError.code;
        }
        return error;
    }
    if (message.length > 0) {
        return new Error(`${String(originalError)}: ${message}`);
    }
    return new Error(String(originalError));
} //# sourceMappingURL=errors.mjs.map
}),
"[project]/node_modules/@metamask/utils/dist/assert.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AssertionError",
    ()=>AssertionError,
    "assert",
    ()=>assert,
    "assertExhaustive",
    ()=>assertExhaustive,
    "assertStruct",
    ()=>assertStruct
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/utils/dist/errors.mjs [app-ssr] (ecmascript)");
;
;
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */ function isConstructable(fn) {
    /* istanbul ignore next */ return Boolean(typeof fn?.prototype?.constructor?.name === 'string');
}
/**
 * Attempts to obtain the message from a possible error object. If it is
 * possible to do so, any trailing period will be removed from the message;
 * otherwise an empty string is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The message without any trailing period if `error` is an object
 * with a `message` property; the string version of `error` without any trailing
 * period if it is not `undefined` or `null`; otherwise an empty string.
 */ function getErrorMessageWithoutTrailingPeriod(error) {
    // We'll add our own period.
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getErrorMessage"])(error).replace(/\.$/u, '');
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */ // eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message
        });
    }
    return ErrorWrapper({
        message
    });
}
class AssertionError extends Error {
    constructor(options){
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
function assert(value, message = 'Assertion failed.', // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
function assertStruct(value, struct, errorPrefix = 'Assertion failed', // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assert"])(value, struct);
    } catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);
    }
}
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
} //# sourceMappingURL=assert.mjs.map
}),
"[project]/node_modules/@metamask/utils/dist/json.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "JsonRpcErrorStruct",
    ()=>JsonRpcErrorStruct,
    "JsonRpcFailureStruct",
    ()=>JsonRpcFailureStruct,
    "JsonRpcIdStruct",
    ()=>JsonRpcIdStruct,
    "JsonRpcNotificationStruct",
    ()=>JsonRpcNotificationStruct,
    "JsonRpcParamsStruct",
    ()=>JsonRpcParamsStruct,
    "JsonRpcRequestStruct",
    ()=>JsonRpcRequestStruct,
    "JsonRpcResponseStruct",
    ()=>JsonRpcResponseStruct,
    "JsonRpcSuccessStruct",
    ()=>JsonRpcSuccessStruct,
    "JsonRpcVersionStruct",
    ()=>JsonRpcVersionStruct,
    "JsonStruct",
    ()=>JsonStruct,
    "PendingJsonRpcResponseStruct",
    ()=>PendingJsonRpcResponseStruct,
    "UnsafeJsonStruct",
    ()=>UnsafeJsonStruct,
    "assertIsJsonRpcError",
    ()=>assertIsJsonRpcError,
    "assertIsJsonRpcFailure",
    ()=>assertIsJsonRpcFailure,
    "assertIsJsonRpcNotification",
    ()=>assertIsJsonRpcNotification,
    "assertIsJsonRpcRequest",
    ()=>assertIsJsonRpcRequest,
    "assertIsJsonRpcResponse",
    ()=>assertIsJsonRpcResponse,
    "assertIsJsonRpcSuccess",
    ()=>assertIsJsonRpcSuccess,
    "assertIsPendingJsonRpcResponse",
    ()=>assertIsPendingJsonRpcResponse,
    "exactOptional",
    ()=>exactOptional,
    "getJsonRpcIdValidator",
    ()=>getJsonRpcIdValidator,
    "getJsonSize",
    ()=>getJsonSize,
    "getSafeJson",
    ()=>getSafeJson,
    "isJsonRpcError",
    ()=>isJsonRpcError,
    "isJsonRpcFailure",
    ()=>isJsonRpcFailure,
    "isJsonRpcNotification",
    ()=>isJsonRpcNotification,
    "isJsonRpcRequest",
    ()=>isJsonRpcRequest,
    "isJsonRpcResponse",
    ()=>isJsonRpcResponse,
    "isJsonRpcSuccess",
    ()=>isJsonRpcSuccess,
    "isPendingJsonRpcResponse",
    ()=>isPendingJsonRpcResponse,
    "isValidJson",
    ()=>isValidJson,
    "jsonrpc2",
    ()=>jsonrpc2,
    "object",
    ()=>object
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/types.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$coercions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/coercions.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/utilities.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$refinements$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/refinements.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/utils/dist/assert.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/utils/dist/misc.mjs [app-ssr] (ecmascript)");
;
;
;
const object = (schema)=>// The type is slightly different from a regular object struct, because we
    // want to make properties with `undefined` in their type optional, but not
    // `undefined` itself. This means that we need a type cast.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(schema);
/**
 * Check the last field of a path is present.
 *
 * @param context - The context to check.
 * @param context.path - The path to check.
 * @param context.branch - The branch to check.
 * @returns Whether the last field of a path is present.
 */ function hasOptional({ path, branch }) {
    const field = path[path.length - 1];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasProperty"])(branch[branch.length - 2], field);
}
function exactOptional(struct) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        type: `optional ${struct.type}`,
        validator: (value, context)=>!hasOptional(context) || struct.validator(value, context),
        refiner: (value, context)=>!hasOptional(context) || struct.refiner(value, context)
    });
}
/**
 * Validate an unknown input to be valid JSON.
 *
 * Useful for constructing JSON structs.
 *
 * @param json - An unknown value.
 * @returns True if the value is valid JSON, otherwise false.
 */ function validateJson(json) {
    if (json === null || typeof json === 'boolean' || typeof json === 'string') {
        return true;
    }
    if (typeof json === 'number' && Number.isFinite(json)) {
        return true;
    }
    if (typeof json === 'object') {
        let every = true;
        if (Array.isArray(json)) {
            // Ignoring linting error since for-of is significantly slower than a normal for-loop
            // and performance is important in this specific function.
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for(let i = 0; i < json.length; i++){
                if (!validateJson(json[i])) {
                    every = false;
                    break;
                }
            }
            return every;
        }
        const entries = Object.entries(json);
        // Ignoring linting errors since for-of is significantly slower than a normal for-loop
        // and performance is important in this specific function.
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for(let i = 0; i < entries.length; i++){
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (typeof entries[i][0] !== 'string' || !validateJson(entries[i][1])) {
                every = false;
                break;
            }
        }
        return every;
    }
    return false;
}
const UnsafeJsonStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('JSON', (json)=>validateJson(json));
const JsonStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$coercions$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["coerce"])(UnsafeJsonStruct, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$refinements$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["refine"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["any"])(), 'JSON', (value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(value, UnsafeJsonStruct)), (value)=>JSON.parse(JSON.stringify(value, (propKey, propValue)=>{
        // Strip __proto__ and constructor properties to prevent prototype pollution.
        if (propKey === '__proto__' || propKey === 'constructor') {
            return undefined;
        }
        return propValue;
    })));
function isValidJson(value) {
    try {
        getSafeJson(value);
        return true;
    } catch  {
        return false;
    }
}
function getSafeJson(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"])(value, JsonStruct);
}
function getJsonSize(value) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(value, JsonStruct, 'Invalid JSON value');
    const json = JSON.stringify(value);
    return new TextEncoder().encode(json).byteLength;
}
const jsonrpc2 = '2.0';
const JsonRpcVersionStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["literal"])(jsonrpc2);
const JsonRpcIdStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nullable"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["union"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["number"])(),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])()
]));
const JsonRpcErrorStruct = object({
    code: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["integer"])(),
    message: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(),
    data: exactOptional(JsonStruct),
    stack: exactOptional((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])())
});
const JsonRpcParamsStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["union"])([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["record"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), JsonStruct),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["array"])(JsonStruct)
]);
const JsonRpcRequestStruct = object({
    id: JsonRpcIdStruct,
    jsonrpc: JsonRpcVersionStruct,
    method: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(),
    params: exactOptional(JsonRpcParamsStruct)
});
const JsonRpcNotificationStruct = object({
    jsonrpc: JsonRpcVersionStruct,
    method: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(),
    params: exactOptional(JsonRpcParamsStruct)
});
function isJsonRpcNotification(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(value, JsonRpcNotificationStruct);
}
function assertIsJsonRpcNotification(value, // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(value, JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
function isJsonRpcRequest(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(value, JsonRpcRequestStruct);
}
function assertIsJsonRpcRequest(value, // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(value, JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
const PendingJsonRpcResponseStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])({
    id: JsonRpcIdStruct,
    jsonrpc: JsonRpcVersionStruct,
    result: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unknown"])()),
    error: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])(JsonRpcErrorStruct)
});
const JsonRpcSuccessStruct = object({
    id: JsonRpcIdStruct,
    jsonrpc: JsonRpcVersionStruct,
    result: JsonStruct
});
const JsonRpcFailureStruct = object({
    id: JsonRpcIdStruct,
    jsonrpc: JsonRpcVersionStruct,
    error: JsonRpcErrorStruct
});
const JsonRpcResponseStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["union"])([
    JsonRpcSuccessStruct,
    JsonRpcFailureStruct
]);
function isPendingJsonRpcResponse(response) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(response, PendingJsonRpcResponseStruct);
}
function assertIsPendingJsonRpcResponse(response, // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(response, PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
function isJsonRpcResponse(response) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(response, JsonRpcResponseStruct);
}
function assertIsJsonRpcResponse(value, // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(value, JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
function isJsonRpcSuccess(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(value, JsonRpcSuccessStruct);
}
function assertIsJsonRpcSuccess(value, // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(value, JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
function isJsonRpcFailure(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(value, JsonRpcFailureStruct);
}
function assertIsJsonRpcFailure(value, // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(value, JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
function isJsonRpcError(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(value, JsonRpcErrorStruct);
}
function assertIsJsonRpcError(value, // eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$assert$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertStruct"])(value, JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = {
        permitEmptyString: true,
        permitFractions: false,
        permitNull: true,
        ...options
    };
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */ const isValidJsonRpcId = (id)=>{
        return Boolean(typeof id === 'number' && (permitFractions || Number.isInteger(id)) || typeof id === 'string' && (permitEmptyString || id.length > 0) || permitNull && id === null);
    };
    return isValidJsonRpcId;
} //# sourceMappingURL=json.mjs.map
}),
"[project]/node_modules/fast-safe-stringify/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = stringify;
stringify.default = stringify;
stringify.stable = deterministicStringify;
stringify.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = '[...]';
var CIRCULAR_REPLACE_NODE = '[Circular]';
var arr = [];
var replacerStack = [];
function defaultOptions() {
    return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
    };
}
// Regular stringify
function stringify(obj, replacer, spacer, options) {
    if (typeof options === 'undefined') {
        options = defaultOptions();
    }
    decirc(obj, '', 0, [], undefined, 0, options);
    var res;
    try {
        if (replacerStack.length === 0) {
            res = JSON.stringify(obj, replacer, spacer);
        } else {
            res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
    } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
    } finally{
        while(arr.length !== 0){
            var part = arr.pop();
            if (part.length === 4) {
                Object.defineProperty(part[0], part[1], part[3]);
            } else {
                part[0][part[1]] = part[2];
            }
        }
    }
    return res;
}
function setReplace(replace, val, k, parent) {
    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
    if (propertyDescriptor.get !== undefined) {
        if (propertyDescriptor.configurable) {
            Object.defineProperty(parent, k, {
                value: replace
            });
            arr.push([
                parent,
                k,
                val,
                propertyDescriptor
            ]);
        } else {
            replacerStack.push([
                val,
                k,
                replace
            ]);
        }
    } else {
        parent[k] = replace;
        arr.push([
            parent,
            k,
            val
        ]);
    }
}
function decirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === 'object' && val !== null) {
        for(i = 0; i < stack.length; i++){
            if (stack[i] === val) {
                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
                return;
            }
        }
        if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
            for(i = 0; i < val.length; i++){
                decirc(val[i], i, i, stack, val, depth, options);
            }
        } else {
            var keys = Object.keys(val);
            for(i = 0; i < keys.length; i++){
                var key = keys[i];
                decirc(val[key], key, i, stack, val, depth, options);
            }
        }
        stack.pop();
    }
}
// Stable-stringify
function compareFunction(a, b) {
    if (a < b) {
        return -1;
    }
    if (a > b) {
        return 1;
    }
    return 0;
}
function deterministicStringify(obj, replacer, spacer, options) {
    if (typeof options === 'undefined') {
        options = defaultOptions();
    }
    var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
    var res;
    try {
        if (replacerStack.length === 0) {
            res = JSON.stringify(tmp, replacer, spacer);
        } else {
            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
    } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]');
    } finally{
        // Ensure that we restore the object as it was.
        while(arr.length !== 0){
            var part = arr.pop();
            if (part.length === 4) {
                Object.defineProperty(part[0], part[1], part[3]);
            } else {
                part[0][part[1]] = part[2];
            }
        }
    }
    return res;
}
function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
    depth += 1;
    var i;
    if (typeof val === 'object' && val !== null) {
        for(i = 0; i < stack.length; i++){
            if (stack[i] === val) {
                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
                return;
            }
        }
        try {
            if (typeof val.toJSON === 'function') {
                return;
            }
        } catch (_) {
            return;
        }
        if (typeof options.depthLimit !== 'undefined' && depth > options.depthLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        if (typeof options.edgesLimit !== 'undefined' && edgeIndex + 1 > options.edgesLimit) {
            setReplace(LIMIT_REPLACE_NODE, val, k, parent);
            return;
        }
        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
            for(i = 0; i < val.length; i++){
                deterministicDecirc(val[i], i, i, stack, val, depth, options);
            }
        } else {
            // Create a temporary object in the required way
            var tmp = {};
            var keys = Object.keys(val).sort(compareFunction);
            for(i = 0; i < keys.length; i++){
                var key = keys[i];
                deterministicDecirc(val[key], key, i, stack, val, depth, options);
                tmp[key] = val[key];
            }
            if (typeof parent !== 'undefined') {
                arr.push([
                    parent,
                    k,
                    val
                ]);
                parent[k] = tmp;
            } else {
                return tmp;
            }
        }
        stack.pop();
    }
}
// wraps replacer function to handle values we couldn't replace
// and mark them as replaced value
function replaceGetterValues(replacer) {
    replacer = typeof replacer !== 'undefined' ? replacer : function(k, v) {
        return v;
    };
    return function(key, val) {
        if (replacerStack.length > 0) {
            for(var i = 0; i < replacerStack.length; i++){
                var part = replacerStack[i];
                if (part[1] === key && part[0] === val) {
                    val = part[2];
                    replacerStack.splice(i, 1);
                    break;
                }
            }
        }
        return replacer.call(this, key, val);
    };
}
}),
"[project]/node_modules/@metamask/superstruct/dist/error.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * A `StructFailure` represents a single specific failure in validation.
 */ /**
 * `StructError` objects are thrown (or returned) when validation fails.
 *
 * Validation logic is design to exit early for maximum performance. The error
 * represents the first error encountered during validation. For more detail,
 * the `error.failures` property is a generator function that can be run to
 * continue validation and receive all the failures in the data.
 */ __turbopack_context__.s([
    "StructError",
    ()=>StructError
]);
class StructError extends TypeError {
    constructor(failure, failures){
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
        super(explanation ?? cause);
        if (explanation !== null && explanation !== undefined) {
            this.cause = cause;
        }
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = ()=>{
            return cached ?? (cached = [
                failure,
                ...failures()
            ]);
        };
    }
} //# sourceMappingURL=error.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Check if a value is an iterator.
 *
 * @param value - The value to check.
 * @returns Whether the value is an iterator.
 */ __turbopack_context__.s([
    "isObject",
    ()=>isObject,
    "isPlainObject",
    ()=>isPlainObject,
    "print",
    ()=>print,
    "run",
    ()=>run,
    "shiftIterator",
    ()=>shiftIterator,
    "toFailure",
    ()=>toFailure,
    "toFailures",
    ()=>toFailures
]);
function isIterable(value) {
    return isObject(value) && typeof value[Symbol.iterator] === 'function';
}
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
function isPlainObject(value) {
    if (Object.prototype.toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
}
function print(value) {
    if (typeof value === 'symbol') {
        return value.toString();
    }
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
    const { done, value } = input.next();
    return done ? undefined : value;
}
function toFailure(result, context, struct, value) {
    if (result === true) {
        return undefined;
    } else if (result === false) {
        // eslint-disable-next-line no-param-reassign
        result = {};
    } else if (typeof result === 'string') {
        // eslint-disable-next-line no-param-reassign
        result = {
            message: result
        };
    }
    const { path, branch } = context;
    const { type } = struct;
    const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\`` } = result;
    return {
        value,
        type,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message
    };
}
function* toFailures(result, context, struct, value) {
    if (!isIterable(result)) {
        // eslint-disable-next-line no-param-reassign
        result = [
            result
        ];
    }
    for (const validationResult of result){
        const failure = toFailure(validationResult, context, struct, value);
        if (failure) {
            yield failure;
        }
    }
}
function* run(value, struct, options = {}) {
    const { path = [], branch = [
        value
    ], coerce = false, mask = false } = options;
    const context = {
        path,
        branch
    };
    if (coerce) {
        // eslint-disable-next-line no-param-reassign
        value = struct.coercer(value, context);
        if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
            for(const key in value){
                if (struct.schema[key] === undefined) {
                    delete value[key];
                }
            }
        }
    }
    let status = 'valid';
    for (const failure of struct.validator(value, context)){
        failure.explanation = options.message;
        status = 'not_valid';
        yield [
            failure,
            undefined
        ];
    }
    // eslint-disable-next-line prefer-const
    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)){
        const iterable = run(innerValue, innerStruct, {
            path: innerKey === undefined ? path : [
                ...path,
                innerKey
            ],
            branch: innerKey === undefined ? branch : [
                ...branch,
                innerValue
            ],
            coerce,
            mask,
            message: options.message
        });
        for (const result of iterable){
            if (result[0]) {
                status = result[0].refinement === null || result[0].refinement === undefined ? 'not_valid' : 'not_refined';
                yield [
                    result[0],
                    undefined
                ];
            } else if (coerce) {
                innerValue = result[1];
                if (innerKey === undefined) {
                    // eslint-disable-next-line no-param-reassign
                    value = innerValue;
                } else if (value instanceof Map) {
                    value.set(innerKey, innerValue);
                } else if (value instanceof Set) {
                    value.add(innerValue);
                } else if (isObject(value)) {
                    if (innerValue !== undefined || innerKey in value) {
                        value[innerKey] = innerValue;
                    }
                }
            }
        }
    }
    if (status !== 'not_valid') {
        for (const failure of struct.refiner(value, context)){
            failure.explanation = options.message;
            status = 'not_refined';
            yield [
                failure,
                undefined
            ];
        }
    }
    if (status === 'valid') {
        yield [
            undefined,
            value
        ];
    }
} //# sourceMappingURL=utils.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ExactOptionalStruct",
    ()=>ExactOptionalStruct,
    "Struct",
    ()=>Struct,
    "assert",
    ()=>assert,
    "create",
    ()=>create,
    "is",
    ()=>is,
    "mask",
    ()=>mask,
    "validate",
    ()=>validate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$error$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/error.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)");
;
;
class Struct {
    constructor(props){
        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {
        /* noop */ } } = props;
        this.type = type;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
            this.validator = (value, context)=>{
                const result = validator(value, context);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFailures"])(result, context, this, value);
            };
        } else {
            this.validator = ()=>[];
        }
        if (refiner) {
            this.refiner = (value, context)=>{
                const result = refiner(value, context);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFailures"])(result, context, this, value);
            };
        } else {
            this.refiner = ()=>[];
        }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */ assert(value, message) {
        return assert(value, this, message);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */ create(value, message) {
        return create(value, this, message);
    }
    /**
     * Check if a value passes the struct's validation.
     */ is(value) {
        return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema.
     */ mask(value, message) {
        return mask(value, this, message);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `withCoercion` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful.
     */ validate(value, options = {}) {
        return validate(value, this, options);
    }
}
// String instead of a Symbol in case of multiple different versions of this library.
const ExactOptionalBrand = 'EXACT_OPTIONAL';
class ExactOptionalStruct extends Struct {
    constructor(props){
        super({
            ...props,
            type: `exact optional ${props.type}`
        });
        this.brand = ExactOptionalBrand;
    }
    static isExactOptional(value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) && 'brand' in value && value.brand === ExactOptionalBrand;
    }
}
function assert(value, struct, message) {
    const result = validate(value, struct, {
        message
    });
    if (result[0]) {
        throw result[0];
    }
}
function create(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        message
    });
    if (result[0]) {
        throw result[0];
    } else {
        return result[1];
    }
}
function mask(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        mask: true,
        message
    });
    if (result[0]) {
        throw result[0];
    } else {
        return result[1];
    }
}
function is(value, struct) {
    const result = validate(value, struct);
    return !result[0];
}
function validate(value, struct, options = {}) {
    const tuples = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["run"])(value, struct, options);
    const tuple = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shiftIterator"])(tuples);
    if (tuple[0]) {
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$error$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StructError"](tuple[0], function*() {
            for (const innerTuple of tuples){
                if (innerTuple[0]) {
                    yield innerTuple[0];
                }
            }
        });
        return [
            error,
            undefined
        ];
    }
    const validatedValue = tuple[1];
    return [
        undefined,
        validatedValue
    ];
} //# sourceMappingURL=struct.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/utilities.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "assign",
    ()=>assign,
    "define",
    ()=>define,
    "deprecated",
    ()=>deprecated,
    "dynamic",
    ()=>dynamic,
    "lazy",
    ()=>lazy,
    "omit",
    ()=>omit,
    "partial",
    ()=>partial,
    "pick",
    ()=>pick
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/types.mjs [app-ssr] (ecmascript)");
;
;
function assign(...Structs) {
    const isType = Structs[0]?.type === 'type';
    const schemas = Structs.map(({ schema })=>schema);
    const schema = Object.assign({}, ...schemas);
    return isType ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(schema) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(schema);
}
function define(name, validator) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: name,
        schema: null,
        validator
    });
}
function deprecated(struct, log) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),
        validator (value, ctx) {
            if (value === undefined) {
                return true;
            }
            log(value, ctx);
            return struct.validator(value, ctx);
        }
    });
}
function dynamic(fn) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'dynamic',
        schema: null,
        *entries (value, ctx) {
            const struct = fn(value, ctx);
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            const struct = fn(value, ctx);
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            const struct = fn(value, ctx);
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            const struct = fn(value, ctx);
            return struct.refiner(value, ctx);
        }
    });
}
function lazy(fn) {
    let struct;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'lazy',
        schema: null,
        *entries (value, ctx) {
            struct ?? (struct = fn());
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            struct ?? (struct = fn());
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            struct ?? (struct = fn());
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            struct ?? (struct = fn());
            return struct.refiner(value, ctx);
        }
    });
}
function omit(struct, keys) {
    const { schema } = struct;
    const subschema = {
        ...schema
    };
    for (const key of keys){
        delete subschema[key];
    }
    switch(struct.type){
        case 'type':
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(subschema);
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(subschema);
    }
}
function partial(struct) {
    const isStruct = struct instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"];
    const schema = isStruct ? {
        ...struct.schema
    } : {
        ...struct
    };
    // eslint-disable-next-line guard-for-in
    for(const key in schema){
        schema[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])(schema[key]);
    }
    if (isStruct && struct.type === 'type') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(schema);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(schema);
}
function pick(struct, keys) {
    const { schema } = struct;
    const subschema = {};
    for (const key of keys){
        subschema[key] = schema[key];
    }
    switch(struct.type){
        case 'type':
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(subschema);
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(subschema);
    }
} //# sourceMappingURL=utilities.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/types.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "any",
    ()=>any,
    "array",
    ()=>array,
    "bigint",
    ()=>bigint,
    "boolean",
    ()=>boolean,
    "date",
    ()=>date,
    "enums",
    ()=>enums,
    "exactOptional",
    ()=>exactOptional,
    "func",
    ()=>func,
    "instance",
    ()=>instance,
    "integer",
    ()=>integer,
    "intersection",
    ()=>intersection,
    "literal",
    ()=>literal,
    "map",
    ()=>map,
    "never",
    ()=>never,
    "nullable",
    ()=>nullable,
    "number",
    ()=>number,
    "object",
    ()=>object,
    "optional",
    ()=>optional,
    "record",
    ()=>record,
    "regexp",
    ()=>regexp,
    "set",
    ()=>set,
    "string",
    ()=>string,
    "tuple",
    ()=>tuple,
    "type",
    ()=>type,
    "union",
    ()=>union,
    "unknown",
    ()=>unknown
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/utilities.mjs [app-ssr] (ecmascript)");
;
;
;
function any() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('any', ()=>true);
}
function array(Element) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'array',
        schema: Element,
        *entries (value) {
            if (Element && Array.isArray(value)) {
                for (const [index, arrayValue] of value.entries()){
                    yield [
                        index,
                        arrayValue,
                        Element
                    ];
                }
            }
        },
        coercer (value) {
            return Array.isArray(value) ? value.slice() : value;
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array value, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function bigint() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('bigint', (value)=>{
        return typeof value === 'bigint';
    });
}
function boolean() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('boolean', (value)=>{
        return typeof value === 'boolean';
    });
}
function date() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('date', (value)=>{
        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function enums(values) {
    const schema = {};
    const description = values.map((value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)).join();
    for (const key of values){
        schema[key] = key;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'enums',
        schema,
        validator (value) {
            return values.includes(value) || `Expected one of \`${description}\`, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function func() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('func', (value)=>{
        return typeof value === 'function' || `Expected a function, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function instance(Class) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('instance', (value)=>{
        return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function integer() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('integer', (value)=>{
        return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function intersection(Structs) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'intersection',
        schema: null,
        *entries (value, context) {
            for (const { entries } of Structs){
                yield* entries(value, context);
            }
        },
        *validator (value, context) {
            for (const { validator } of Structs){
                yield* validator(value, context);
            }
        },
        *refiner (value, context) {
            for (const { refiner } of Structs){
                yield* refiner(value, context);
            }
        }
    });
}
function literal(constant) {
    const description = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(constant);
    const valueType = typeof constant;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'literal',
        schema: valueType === 'string' || valueType === 'number' || valueType === 'boolean' ? constant : null,
        validator (value) {
            return value === constant || `Expected the literal \`${description}\`, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function map(Key, Value) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'map',
        schema: null,
        *entries (value) {
            if (Key && Value && value instanceof Map) {
                for (const [mapKey, mapValue] of value.entries()){
                    yield [
                        mapKey,
                        mapKey,
                        Key
                    ];
                    yield [
                        mapKey,
                        mapValue,
                        Value
                    ];
                }
            }
        },
        coercer (value) {
            return value instanceof Map ? new Map(value) : value;
        },
        validator (value) {
            return value instanceof Map || `Expected a \`Map\` object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function never() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('never', ()=>false);
}
function nullable(struct) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        validator: (value, ctx)=>value === null || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)
    });
}
function number() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('number', (value)=>{
        return typeof value === 'number' && !isNaN(value) || `Expected a number, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function object(schema) {
    const knowns = schema ? Object.keys(schema) : [];
    const Never = never();
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'object',
        schema: schema ?? null,
        *entries (value) {
            if (schema && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value)) {
                const unknowns = new Set(Object.keys(value));
                for (const key of knowns){
                    unknowns.delete(key);
                    const propertySchema = schema[key];
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExactOptionalStruct"].isExactOptional(propertySchema) && !Object.prototype.hasOwnProperty.call(value, key)) {
                        continue;
                    }
                    yield [
                        key,
                        value[key],
                        schema[key]
                    ];
                }
                for (const key of unknowns){
                    yield [
                        key,
                        value[key],
                        Never
                    ];
                }
            }
        },
        validator (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) || `Expected an object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        },
        coercer (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) ? {
                ...value
            } : value;
        }
    });
}
function optional(struct) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)
    });
}
function exactOptional(struct) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExactOptionalStruct"](struct);
}
function record(Key, Value) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'record',
        schema: null,
        *entries (value) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value)) {
                // eslint-disable-next-line guard-for-in
                for(const objectKey in value){
                    const objectValue = value[objectKey];
                    yield [
                        objectKey,
                        objectKey,
                        Key
                    ];
                    yield [
                        objectKey,
                        objectValue,
                        Value
                    ];
                }
            }
        },
        validator (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) || `Expected an object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function regexp() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('regexp', (value)=>{
        return value instanceof RegExp;
    });
}
function set(Element) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'set',
        schema: null,
        *entries (value) {
            if (Element && value instanceof Set) {
                for (const setValue of value){
                    yield [
                        setValue,
                        setValue,
                        Element
                    ];
                }
            }
        },
        coercer (value) {
            return value instanceof Set ? new Set(value) : value;
        },
        validator (value) {
            return value instanceof Set || `Expected a \`Set\` object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function string() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('string', (value)=>{
        return typeof value === 'string' || `Expected a string, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function tuple(Structs) {
    const Never = never();
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'tuple',
        schema: null,
        *entries (value) {
            if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for(let i = 0; i < length; i++){
                    yield [
                        i,
                        value[i],
                        Structs[i] || Never
                    ];
                }
            }
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function type(schema) {
    const keys = Object.keys(schema);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'type',
        schema,
        *entries (value) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value)) {
                for (const k of keys){
                    yield [
                        k,
                        value[k],
                        schema[k]
                    ];
                }
            }
        },
        validator (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) || `Expected an object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        },
        coercer (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) ? {
                ...value
            } : value;
        }
    });
}
function union(Structs) {
    const description = Structs.map((struct)=>struct.type).join(' | ');
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'union',
        schema: null,
        coercer (value) {
            for (const InnerStruct of Structs){
                const [error, coerced] = InnerStruct.validate(value, {
                    coerce: true
                });
                if (!error) {
                    return coerced;
                }
            }
            return value;
        },
        validator (value, ctx) {
            const failures = [];
            for (const InnerStruct of Structs){
                const [...tuples] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["run"])(value, InnerStruct, ctx);
                const [first] = tuples;
                if (!first?.[0]) {
                    return [];
                }
                for (const [failure] of tuples){
                    if (failure) {
                        failures.push(failure);
                    }
                }
            }
            return [
                `Expected the value to satisfy a union of \`${description}\`, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`,
                ...failures
            ];
        }
    });
}
function unknown() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('unknown', ()=>true);
} //# sourceMappingURL=types.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/coercions.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "coerce",
    ()=>coerce,
    "defaulted",
    ()=>defaulted,
    "trimmed",
    ()=>trimmed
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/types.mjs [app-ssr] (ecmascript)");
;
;
;
function coerce(struct, condition, coercer) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        coercer: (value, ctx)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["is"])(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
        }
    });
}
function defaulted(struct, fallback, options = {}) {
    return coerce(struct, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unknown"])(), (value)=>{
        const result = typeof fallback === 'function' ? fallback() : fallback;
        if (value === undefined) {
            return result;
        }
        if (!options.strict && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPlainObject"])(value) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPlainObject"])(result)) {
            const ret = {
                ...value
            };
            let changed = false;
            for(const key in result){
                if (ret[key] === undefined) {
                    ret[key] = result[key];
                    changed = true;
                }
            }
            if (changed) {
                return ret;
            }
        }
        return value;
    });
}
function trimmed(struct) {
    return coerce(struct, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"])(), (value)=>value.trim());
} //# sourceMappingURL=coercions.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/refinements.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "empty",
    ()=>empty,
    "max",
    ()=>max,
    "min",
    ()=>min,
    "nonempty",
    ()=>nonempty,
    "pattern",
    ()=>pattern,
    "refine",
    ()=>refine,
    "size",
    ()=>size
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)");
;
;
function empty(struct) {
    return refine(struct, 'empty', (value)=>{
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const size = getSize(value);
        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \`${size}\``;
    });
}
/**
 * Get the size of a string, array, map, or set.
 *
 * @param value - The value to measure.
 * @returns The size of the value.
 */ function getSize(value) {
    if (value instanceof Map || value instanceof Set) {
        return value.size;
    }
    return value.length;
}
function max(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'max', (value)=>{
        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
function min(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'min', (value)=>{
        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
function nonempty(struct) {
    return refine(struct, 'nonempty', (value)=>{
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const size = getSize(value);
        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;
    });
}
function pattern(struct, regexp) {
    return refine(struct, 'pattern', (value)=>{
        return regexp.test(value) || `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`;
    });
}
function size(struct, minimum, maximum = minimum) {
    const expected = `Expected a ${struct.type}`;
    const of = minimum === maximum ? `of \`${minimum}\`` : `between \`${minimum}\` and \`${maximum}\``;
    return refine(struct, 'size', (value)=>{
        if (typeof value === 'number' || value instanceof Date) {
            return minimum <= value && value <= maximum || // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${expected} ${of} but received \`${value}\``;
        } else if (value instanceof Map || value instanceof Set) {
            // eslint-disable-next-line @typescript-eslint/no-shadow
            const { size } = value;
            return minimum <= size && size <= maximum || `${expected} with a size ${of} but received one with a size of \`${size}\``;
        }
        const { length } = value;
        return minimum <= length && length <= maximum || `${expected} with a length ${of} but received one with a length of \`${length}\``;
    });
}
function refine(struct, name, refiner) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        *refiner (value, ctx) {
            yield* struct.refiner(value, ctx);
            const result = refiner(value, ctx);
            const failures = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFailures"])(result, ctx, struct, value);
            for (const failure of failures){
                yield {
                    ...failure,
                    refinement: name
                };
            }
        }
    });
} //# sourceMappingURL=refinements.mjs.map
}),
"[project]/node_modules/pony-cause/lib/error-with-cause.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ErrorWithCause",
    ()=>ErrorWithCause
]);
'use strict';
class ErrorWithCause extends Error {
    /**
   * @param {string} message
   * @param {{ cause?: T }} options
   */ constructor(message, { cause } = {}){
        super(message);
        /** @type {string} */ this.name = ErrorWithCause.name;
        if (cause) {
            /** @type {T} */ this.cause = cause;
        }
        /** @type {string} */ this.message = message;
    }
}
}),
"[project]/node_modules/pony-cause/lib/helpers.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "findCauseByReference",
    ()=>findCauseByReference,
    "getErrorCause",
    ()=>getErrorCause,
    "messageWithCauses",
    ()=>messageWithCauses,
    "stackWithCauses",
    ()=>stackWithCauses
]);
'use strict';
const findCauseByReference = (err, reference)=>{
    if (!err || !reference) return;
    if (!(err instanceof Error)) return;
    if (!(reference.prototype instanceof Error) && // @ts-ignore
    reference !== Error) return;
    /**
   * Ensures we don't go circular
   *
   * @type {Set<Error>}
   */ const seen = new Set();
    /** @type {Error|undefined} */ let currentErr = err;
    while(currentErr && !seen.has(currentErr)){
        seen.add(currentErr);
        if (currentErr instanceof reference) {
            return currentErr;
        }
        currentErr = getErrorCause(currentErr);
    }
};
const getErrorCause = (err)=>{
    if (!err || typeof err !== 'object' || !('cause' in err)) {
        return;
    }
    // VError / NError style causes
    if (typeof err.cause === 'function') {
        const causeResult = err.cause();
        return causeResult instanceof Error ? causeResult : undefined;
    } else {
        return err.cause instanceof Error ? err.cause : undefined;
    }
};
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @returns {string}
 */ const _stackWithCauses = (err, seen)=>{
    if (!(err instanceof Error)) return '';
    const stack = err.stack || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return stack + '\ncauses have become circular...';
    }
    const cause = getErrorCause(err);
    // TODO: Follow up in https://github.com/nodejs/node/issues/38725#issuecomment-920309092 on how to log stuff
    if (cause) {
        seen.add(err);
        return stack + '\ncaused by: ' + _stackWithCauses(cause, seen);
    } else {
        return stack;
    }
};
const stackWithCauses = (err)=>_stackWithCauses(err, new Set());
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @param {boolean} [skip]
 * @returns {string}
 */ const _messageWithCauses = (err, seen, skip)=>{
    if (!(err instanceof Error)) return '';
    const message = skip ? '' : err.message || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return message + ': ...';
    }
    const cause = getErrorCause(err);
    if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = 'cause' in err && typeof err.cause === 'function';
        return message + (skipIfVErrorStyleCause ? '' : ': ') + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
        return message;
    }
};
const messageWithCauses = (err)=>_messageWithCauses(err, new Set());
}),
"[project]/node_modules/pony-cause/index.mjs [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pony$2d$cause$2f$lib$2f$error$2d$with$2d$cause$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pony-cause/lib/error-with-cause.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pony$2d$cause$2f$lib$2f$helpers$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pony-cause/lib/helpers.mjs [app-ssr] (ecmascript)");
'use strict';
;
;
}),
"[project]/node_modules/@metamask/rpc-errors/dist/error-constants.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "errorCodes",
    ()=>errorCodes,
    "errorValues",
    ()=>errorValues
]);
const errorCodes = {
    rpc: {
        invalidInput: -32000,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
    },
    provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
    }
};
const errorValues = {
    '-32700': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'
    },
    '-32600': {
        standard: 'JSON RPC 2.0',
        message: 'The JSON sent is not a valid Request object.'
    },
    '-32601': {
        standard: 'JSON RPC 2.0',
        message: 'The method does not exist / is not available.'
    },
    '-32602': {
        standard: 'JSON RPC 2.0',
        message: 'Invalid method parameter(s).'
    },
    '-32603': {
        standard: 'JSON RPC 2.0',
        message: 'Internal JSON-RPC error.'
    },
    '-32000': {
        standard: 'EIP-1474',
        message: 'Invalid input.'
    },
    '-32001': {
        standard: 'EIP-1474',
        message: 'Resource not found.'
    },
    '-32002': {
        standard: 'EIP-1474',
        message: 'Resource unavailable.'
    },
    '-32003': {
        standard: 'EIP-1474',
        message: 'Transaction rejected.'
    },
    '-32004': {
        standard: 'EIP-1474',
        message: 'Method not supported.'
    },
    '-32005': {
        standard: 'EIP-1474',
        message: 'Request limit exceeded.'
    },
    '4001': {
        standard: 'EIP-1193',
        message: 'User rejected the request.'
    },
    '4100': {
        standard: 'EIP-1193',
        message: 'The requested account and/or method has not been authorized by the user.'
    },
    '4200': {
        standard: 'EIP-1193',
        message: 'The requested method is not supported by this Ethereum provider.'
    },
    '4900': {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from all chains.'
    },
    '4901': {
        standard: 'EIP-1193',
        message: 'The provider is disconnected from the specified chain.'
    }
}; /* eslint-enable @typescript-eslint/naming-convention */  //# sourceMappingURL=error-constants.mjs.map
}),
"[project]/node_modules/@metamask/rpc-errors/dist/utils.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "JSON_RPC_SERVER_ERROR_MESSAGE",
    ()=>JSON_RPC_SERVER_ERROR_MESSAGE,
    "dataHasCause",
    ()=>dataHasCause,
    "getMessageFromCode",
    ()=>getMessageFromCode,
    "isValidCode",
    ()=>isValidCode,
    "serializeCause",
    ()=>serializeCause,
    "serializeError",
    ()=>serializeError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/utils/dist/misc.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$json$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/utils/dist/json.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/error-constants.mjs [app-ssr] (ecmascript)");
;
;
const FALLBACK_ERROR_CODE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.internal;
const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
};
const JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
    if (isValidCode(code)) {
        const codeString = code.toString();
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasProperty"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorValues"], codeString)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorValues"][codeString].message;
        }
        if (isJsonRpcServerError(code)) {
            return JSON_RPC_SERVER_ERROR_MESSAGE;
        }
    }
    return fallbackMessage;
}
function isValidCode(code) {
    return Number.isInteger(code);
}
function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true, shouldPreserveMessage = true } = {}) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$json$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJsonRpcError"])(fallbackError)) {
        throw new Error('Must provide fallback error with integer number code and string message.');
    }
    const serialized = buildError(error, fallbackError, shouldPreserveMessage);
    if (!shouldIncludeStack) {
        delete serialized.stack;
    }
    return serialized;
}
/**
 * Construct a JSON-serializable object given an error and a JSON-serializable `fallbackError`
 *
 * @param error - The error in question.
 * @param fallbackError - A JSON-serializable fallback error.
 * @param shouldPreserveMessage - Whether to preserve the error's message if the fallback
 * error is used.
 * @returns A JSON-serializable error object.
 */ function buildError(error, fallbackError, shouldPreserveMessage) {
    // If an error specifies a `serialize` function, we call it and return the result.
    if (error && typeof error === 'object' && 'serialize' in error && typeof error.serialize === 'function') {
        return error.serialize();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$json$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJsonRpcError"])(error)) {
        return error;
    }
    const originalMessage = getOriginalMessage(error);
    // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.
    const cause = serializeCause(error);
    const fallbackWithCause = {
        ...fallbackError,
        ...shouldPreserveMessage && originalMessage && {
            message: originalMessage
        },
        data: {
            cause
        }
    };
    return fallbackWithCause;
}
/**
 * Attempts to extract the original `message` property from an error value of uncertain shape.
 *
 * @param error - The error in question.
 * @returns The original message, if it exists and is a non-empty string.
 */ function getOriginalMessage(error) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(error) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasProperty"])(error, 'message') && typeof error.message === 'string' && error.message.length > 0) {
        return error.message;
    }
    return undefined;
}
/**
 * Check if the given code is a valid JSON-RPC server error code.
 *
 * @param code - The error code.
 * @returns Whether the given code is a valid JSON-RPC server error code.
 */ function isJsonRpcServerError(code) {
    return code >= -32099 && code <= -32000;
}
function serializeCause(error) {
    if (Array.isArray(error)) {
        return error.map((entry)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$json$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidJson"])(entry)) {
                return entry;
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(entry)) {
                return serializeObject(entry);
            }
            return null;
        });
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(error)) {
        return serializeObject(error);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$json$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidJson"])(error)) {
        return error;
    }
    return null;
}
/**
 * Extracts all JSON-serializable properties from an object.
 *
 * @param object - The object in question.
 * @returns An object containing all the JSON-serializable properties.
 */ function serializeObject(object) {
    return Object.getOwnPropertyNames(object).reduce((acc, key)=>{
        const value = object[key];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$json$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isValidJson"])(value)) {
            acc[key] = value;
        }
        return acc;
    }, {});
}
function dataHasCause(data) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(data) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasProperty"])(data, 'cause') && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(data.cause);
} //# sourceMappingURL=utils.mjs.map
}),
"[project]/node_modules/@metamask/rpc-errors/dist/classes.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EthereumProviderError",
    ()=>EthereumProviderError,
    "JsonRpcError",
    ()=>JsonRpcError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/utils/dist/misc.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$safe$2d$stringify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-safe-stringify/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/utils.mjs [app-ssr] (ecmascript)");
function $importDefault(module) {
    if (module?.__esModule) {
        return module.default;
    }
    return module;
}
;
;
const safeStringify = $importDefault(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$safe$2d$stringify$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
;
class JsonRpcError extends Error {
    constructor(code, message, data){
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a non-empty string.');
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["dataHasCause"])(data)) {
            // @ts-expect-error - Error class does accept options argument depending on runtime, but types are mapping to oldest supported
            super(message, {
                cause: data.cause
            });
            // Browser backwards-compatibility fallback
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasProperty"])(this, 'cause')) {
                Object.assign(this, {
                    cause: data.cause
                });
            }
        } else {
            super(message);
        }
        if (data !== undefined) {
            this.data = data;
        }
        this.code = code;
    }
    /**
     * Get the error as JSON-serializable object.
     *
     * @returns A plain object with all public class properties.
     */ serialize() {
        const serialized = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            // `this.data` is not guaranteed to be a plain object, but this simplifies
            // the type guard below. We can safely cast it because we know it's a
            // JSON-serializable value.
            serialized.data = this.data;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$misc$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isPlainObject"])(this.data)) {
                serialized.data.cause = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeCause"])(this.data.cause);
            }
        }
        if (this.stack) {
            serialized.stack = this.stack;
        }
        return serialized;
    }
    /**
     * Get a string representation of the serialized error, omitting any circular
     * references.
     *
     * @returns A string representation of the serialized error.
     */ toString() {
        return safeStringify(this.serialize(), stringifyReplacer, 2);
    }
}
class EthereumProviderError extends JsonRpcError {
    /**
     * Create an Ethereum Provider JSON-RPC error.
     *
     * @param code - The JSON-RPC error code. Must be an integer in the
     * `1000 <= n <= 4999` range.
     * @param message - The JSON-RPC error message.
     * @param data - Optional data to include in the error.
     */ constructor(code, message, data){
        if (!isValidEthProviderCode(code)) {
            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
    }
}
/**
 * Check if the given code is a valid JSON-RPC error code.
 *
 * @param code - The code to check.
 * @returns Whether the code is valid.
 */ function isValidEthProviderCode(code) {
    return Number.isInteger(code) && code >= 1000 && code <= 4999;
}
/**
 * A JSON replacer function that omits circular references.
 *
 * @param _ - The key being replaced.
 * @param value - The value being replaced.
 * @returns The value to use in place of the original value.
 */ function stringifyReplacer(_, value) {
    if (value === '[Circular]') {
        return undefined;
    }
    return value;
} //# sourceMappingURL=classes.mjs.map
}),
"[project]/node_modules/@metamask/rpc-errors/dist/errors.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "providerErrors",
    ()=>providerErrors,
    "rpcErrors",
    ()=>rpcErrors
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$classes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/classes.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/error-constants.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/utils.mjs [app-ssr] (ecmascript)");
;
;
;
const rpcErrors = {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ parse: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.parse, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ invalidRequest: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.invalidRequest, arg),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ invalidParams: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.invalidParams, arg),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ methodNotFound: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.methodNotFound, arg),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ internal: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.internal, arg),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     *
     * @param opts - The error options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ server: (opts)=>{
        if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
            throw new Error('Ethereum RPC Server errors must provide single object argument.');
        }
        const { code } = opts;
        if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        }
        return getJsonRpcError(code, opts);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ invalidInput: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.invalidInput, arg),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ resourceNotFound: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.resourceNotFound, arg),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ resourceUnavailable: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.resourceUnavailable, arg),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ transactionRejected: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.transactionRejected, arg),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ methodNotSupported: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.methodNotSupported, arg),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link JsonRpcError} class.
     */ limitExceeded: (arg)=>getJsonRpcError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].rpc.limitExceeded, arg)
};
const providerErrors = {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */ userRejectedRequest: (arg)=>{
        return getEthProviderError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].provider.userRejectedRequest, arg);
    },
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */ unauthorized: (arg)=>{
        return getEthProviderError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].provider.unauthorized, arg);
    },
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */ unsupportedMethod: (arg)=>{
        return getEthProviderError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].provider.unsupportedMethod, arg);
    },
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */ disconnected: (arg)=>{
        return getEthProviderError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].provider.disconnected, arg);
    },
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     *
     * @param arg - The error message or options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */ chainDisconnected: (arg)=>{
        return getEthProviderError(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].provider.chainDisconnected, arg);
    },
    /**
     * Get a custom Ethereum Provider error.
     *
     * @param opts - The error options bag.
     * @returns An instance of the {@link EthereumProviderError} class.
     */ custom: (opts)=>{
        if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
            throw new Error('Ethereum Provider custom errors must provide single object argument.');
        }
        const { code, message, data } = opts;
        if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a nonempty string');
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$classes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumProviderError"](code, message, data);
    }
};
/**
 * Get a generic JSON-RPC error class instance.
 *
 * @param code - The error code.
 * @param arg - The error message or options bag.
 * @returns An instance of the {@link JsonRpcError} class.
 */ function getJsonRpcError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$classes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["JsonRpcError"](code, message ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMessageFromCode"])(code), data);
}
/**
 * Get an Ethereum Provider error class instance.
 *
 * @param code - The error code.
 * @param arg - The error message or options bag.
 * @returns An instance of the {@link EthereumProviderError} class.
 */ function getEthProviderError(code, arg) {
    const [message, data] = parseOpts(arg);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$classes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumProviderError"](code, message ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMessageFromCode"])(code), data);
}
/**
 * Get an error message and optional data from an options bag.
 *
 * @param arg - The error message or options bag.
 * @returns A tuple containing the error message and optional data.
 */ function parseOpts(arg) {
    if (arg) {
        if (typeof arg === 'string') {
            return [
                arg
            ];
        } else if (typeof arg === 'object' && !Array.isArray(arg)) {
            const { message, data } = arg;
            if (message && typeof message !== 'string') {
                throw new Error('Must specify string message.');
            }
            return [
                message ?? undefined,
                data
            ];
        }
    }
    return [];
} //# sourceMappingURL=errors.mjs.map
}),
"[project]/node_modules/@gemini-wallet/core/dist/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/communicator.ts
__turbopack_context__.s([
    "Communicator",
    ()=>Communicator,
    "DEFAULT_CHAIN_ID",
    ()=>DEFAULT_CHAIN_ID,
    "GeminiSdkEvent",
    ()=>GeminiSdkEvent,
    "GeminiStorage",
    ()=>GeminiStorage,
    "GeminiWallet",
    ()=>GeminiWallet,
    "GeminiWalletProvider",
    ()=>GeminiWalletProvider,
    "POPUP_HEIGHT",
    ()=>POPUP_HEIGHT,
    "POPUP_WIDTH",
    ()=>POPUP_WIDTH,
    "PlatformType",
    ()=>PlatformType,
    "ProviderEventEmitter",
    ()=>ProviderEventEmitter,
    "SDK_BACKEND_URL",
    ()=>SDK_BACKEND_URL,
    "SDK_VERSION",
    ()=>SDK_VERSION,
    "STORAGE_ETH_ACCOUNTS_KEY",
    ()=>STORAGE_ETH_ACCOUNTS_KEY,
    "STORAGE_ETH_ACTIVE_CHAIN_KEY",
    ()=>STORAGE_ETH_ACTIVE_CHAIN_KEY,
    "STORAGE_PASSKEY_CREDENTIAL_KEY",
    ()=>STORAGE_PASSKEY_CREDENTIAL_KEY,
    "STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY",
    ()=>STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY,
    "STORAGE_SETTINGS_KEY",
    ()=>STORAGE_SETTINGS_KEY,
    "STORAGE_SMART_ACCOUNT_KEY",
    ()=>STORAGE_SMART_ACCOUNT_KEY,
    "STORAGE_WC_REQUESTS_KEY",
    ()=>STORAGE_WC_REQUESTS_KEY,
    "base64ToHex",
    ()=>base64ToHex,
    "bufferToBase64URLString",
    ()=>bufferToBase64URLString,
    "calculateV1Address",
    ()=>calculateV1Address,
    "calculateWalletAddress",
    ()=>calculateWalletAddress,
    "closePopup",
    ()=>closePopup,
    "convertSendValuesToBigInt",
    ()=>convertSendValuesToBigInt,
    "decodeBase64",
    ()=>decodeBase64,
    "encodeBase64",
    ()=>encodeBase64,
    "fetchRpcRequest",
    ()=>fetchRpcRequest,
    "generateAuthenticatorIdHash",
    ()=>generateAuthenticatorIdHash,
    "hexStringFromNumber",
    ()=>hexStringFromNumber,
    "isChainSupportedByGeminiSw",
    ()=>isChainSupportedByGeminiSw,
    "openPopup",
    ()=>openPopup,
    "reverseResolveEns",
    ()=>reverseResolveEns,
    "safeJsonStringify",
    ()=>safeJsonStringify,
    "utf8StringToBuffer",
    ()=>utf8StringToBuffer,
    "validateRpcRequestArgs",
    ()=>validateRpcRequestArgs,
    "validateWebAuthnKey",
    ()=>validateWebAuthnKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/errors.mjs [app-ssr] (ecmascript)");
// src/constants.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$arbitrum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/arbitrum.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$arbitrumSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/base.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$baseSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/baseSepolia.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$mainnet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/mainnet.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$optimism$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/optimism.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$optimismSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/optimismSepolia.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/polygon.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$polygonAmoy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/polygonAmoy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$sepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/sepolia.js [app-ssr] (ecmascript)");
// src/types.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__EventEmitter$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.js [app-ssr] (ecmascript) <export default as EventEmitter>");
// src/utils/calculateWalletAddress.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodeFunctionData.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodePacked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/abi/encodePacked.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getContractAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getContractAddress.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/hash/keccak256.js [app-ssr] (ecmascript)");
// src/provider/provider.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/error-constants.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/rpc-errors/dist/utils.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/isHex.js [app-ssr] (ecmascript)");
;
;
// package.json
var package_default = {
    name: "@gemini-wallet/core",
    version: "0.3.1",
    description: "Core SDK for Gemini Wallet integration with popup communication",
    main: "./dist/index.cjs",
    types: "./dist/index.d.ts",
    type: "module",
    repository: {
        type: "git",
        url: "git+https://github.com/gemini/gemini-wallet-core.git"
    },
    homepage: "https://keys.gemini.com",
    bugs: {
        url: "https://github.com/gemini/gemini-wallet-core/issues"
    },
    license: "MIT",
    author: "Gemini",
    files: [
        "dist",
        "src",
        "README.md",
        "LICENSE"
    ],
    exports: {
        ".": {
            types: "./dist/index.d.ts",
            import: "./dist/index.js",
            require: "./dist/index.cjs"
        },
        "./package.json": "./package.json"
    },
    scripts: {
        build: "dotenv -e .env.production -- tsup",
        dev: "dotenv -e .env.local -- tsup --watch",
        typecheck: "tsc --noEmit",
        lint: "eslint ./src",
        "lint:ci": "eslint --max-warnings 0 ./src",
        "lint:fix": "eslint ./src --fix",
        test: "bun test"
    },
    dependencies: {
        "@metamask/rpc-errors": "7.0.2",
        eventemitter3: "5.0.1"
    },
    devDependencies: {
        "@eslint/eslintrc": "3.3.1",
        "@eslint/js": "9.33.0",
        "@next/eslint-plugin-next": "15.4.7",
        "@types/node": "22.13.0",
        "dotenv-cli": "10.0.0",
        "esbuild-plugin-replace": "1.4.0",
        eslint: "9.33.0",
        "eslint-config-prettier": "10.1.8",
        "eslint-config-turbo": "2.5.6",
        "eslint-plugin-import": "2.32.0",
        "eslint-plugin-jsx-a11y": "6.10.2",
        "eslint-plugin-only-warn": "1.1.0",
        "eslint-plugin-prettier": "5.5.4",
        "eslint-plugin-react": "7.37.5",
        "eslint-plugin-react-hooks": "5.2.0",
        "eslint-plugin-simple-import-sort": "12.1.1",
        "eslint-plugin-sort-keys-fix": "1.1.2",
        globals: "16.3.0",
        prettier: "3.6.2",
        tsup: "8.4.0",
        typescript: "5.5.3",
        "typescript-eslint": "8.40.0",
        vitest: "3.2.4"
    },
    peerDependencies: {
        viem: ">=2.0.0"
    },
    keywords: [
        "gemini",
        "wallet",
        "sdk",
        "ethereum",
        "web3",
        "crypto"
    ],
    module: "./dist/index.js"
};
// src/constants.ts
var DEFAULT_BACKEND_URL = "https://keys.gemini.com";
var SDK_BACKEND_URL = typeof process !== "undefined" && "undefined" || DEFAULT_BACKEND_URL;
var ENS_API_URL = "https://horizon-api.gemini.com/api/ens";
var SDK_VERSION = package_default.version;
var DEFAULT_CHAIN_ID = 42161;
var MAINNET_CHAIN_IDS = {
    ARBITRUM_ONE: 42161,
    BASE: 8453,
    ETHEREUM: 1,
    OP_MAINNET: 10,
    POLYGON: 137
};
var TESTNET_CHAIN_IDS = {
    ARBITRUM_SEPOLIA: 421614,
    BASE_SEPOLIA: 84532,
    OP_SEPOLIA: 11155420,
    POLYGON_AMOY: 80002,
    SEPOLIA: 11155111
};
var SUPPORTED_CHAIN_IDS = [
    ...Object.values(MAINNET_CHAIN_IDS),
    ...Object.values(TESTNET_CHAIN_IDS)
];
function getDefaultRpcUrl(chainId) {
    const chainMap = {
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$mainnet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mainnet"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$mainnet$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mainnet"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$arbitrum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arbitrum"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$arbitrum$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arbitrum"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$optimism$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optimism"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$optimism$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optimism"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$base$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$polygon$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygon"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$sepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sepolia"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$sepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sepolia"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$arbitrumSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arbitrumSepolia"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$arbitrumSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arbitrumSepolia"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$optimismSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optimismSepolia"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$optimismSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optimismSepolia"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$baseSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["baseSepolia"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$baseSepolia$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["baseSepolia"].rpcUrls.default.http[0],
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$polygonAmoy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonAmoy"].id]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$polygonAmoy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["polygonAmoy"].rpcUrls.default.http[0]
    };
    return chainMap[chainId];
}
var POPUP_WIDTH = 420;
var POPUP_HEIGHT = 650;
;
var GeminiSdkEvent = /* @__PURE__ */ ((GeminiSdkEvent2)=>{
    GeminiSdkEvent2["POPUP_LOADED"] = "POPUP_LOADED";
    GeminiSdkEvent2["POPUP_UNLOADED"] = "POPUP_UNLOADED";
    GeminiSdkEvent2["POPUP_APP_CONTEXT"] = "POPUP_APP_CONTEXT";
    GeminiSdkEvent2["SDK_CONNECT"] = "SDK_CONNECT";
    GeminiSdkEvent2["SDK_DISCONNECT"] = "SDK_DISCONNECT";
    GeminiSdkEvent2["SDK_SEND_TRANSACTION"] = "SDK_SEND_TRANSACTION";
    GeminiSdkEvent2["SDK_SIGN_DATA"] = "SDK_SIGN_DATA";
    GeminiSdkEvent2["SDK_SIGN_TYPED_DATA"] = "SDK_SIGN_TYPED_DATA";
    GeminiSdkEvent2["SDK_SWITCH_CHAIN"] = "SDK_SWITCH_CHAIN";
    GeminiSdkEvent2["SDK_OPEN_SETTINGS"] = "SDK_OPEN_SETTINGS";
    GeminiSdkEvent2["SDK_CURRENT_ACCOUNT"] = "SDK_CURRENT_ACCOUNT";
    return GeminiSdkEvent2;
})(GeminiSdkEvent || {});
var PlatformType = {
    REACT_NATIVE: "REACT_NATIVE",
    WEB: "WEB"
};
var ProviderEventEmitter = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__EventEmitter$3e$__["EventEmitter"] {
};
// src/utils/base64.ts
function encodeBase64(array) {
    let base64;
    if (typeof Buffer !== "undefined") {
        base64 = Buffer.from(array).toString("base64");
    } else {
        base64 = btoa(Array.from(array).map((b)=>String.fromCharCode(b)).join(""));
    }
    return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function decodeBase64(base64url) {
    let base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
    while(base64.length % 4 !== 0){
        base64 += "=";
    }
    if (typeof Buffer !== "undefined") {
        return new Uint8Array(Buffer.from(base64, "base64"));
    } else {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for(let i = 0; i < binaryString.length; i++){
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes;
    }
}
function bufferToBase64URLString(buffer) {
    const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);
    return encodeBase64(bytes);
}
function utf8StringToBuffer(value) {
    if (typeof TextEncoder !== "undefined") {
        return new TextEncoder().encode(value);
    } else if (typeof Buffer !== "undefined") {
        return new Uint8Array(Buffer.from(value, "utf8"));
    } else {
        const bytes = new Uint8Array(value.length);
        for(let i = 0; i < value.length; i++){
            bytes[i] = value.charCodeAt(i);
        }
        return bytes;
    }
}
function base64ToHex(base64) {
    const bytes = decodeBase64(base64);
    return Array.from(bytes).map((b)=>b.toString(16).padStart(2, "0")).join("");
}
;
var SHARED_CONTRACT_ADDRESSES = {
    ATTESTER: "0x000474392a9cd86a4687354f1Ce2964B52e97484",
    BOOTSTRAPPER: "0x00000000D3254452a909E4eeD47455Af7E27C289",
    REGISTRY: "0x000000000069E2a187AEFFb852bF3cCdC95151B2"
};
var V2_CONTRACT_ADDRESSES = {
    ...SHARED_CONTRACT_ADDRESSES,
    ACCOUNT_IMPLEMENTATION: "0x00000000029d9c8b864DD51d6bb0d99FB72D650b",
    FACTORY: "0x000000000452377e1Bd9e72E939855ECb9363Cab",
    WEBAUTHN_VALIDATOR: "0x7ab16Ff354AcB328452F1D445b3Ddee9a91e9e69"
};
var V1_CONTRACT_ADDRESSES = {
    ...SHARED_CONTRACT_ADDRESSES,
    ACCOUNT_IMPLEMENTATION: "0x0006050168DE255a8672ACaD4821e721CBA44337",
    FACTORY: "0x00E58DF70FaB983a324c4C068c82d20407579FaC",
    WEBAUTHN_VALIDATOR: "0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd"
};
function processWalletAddressParams(params, contractAddresses) {
    const { publicKey, credentialId, index = 0n } = params;
    if (!publicKey.startsWith("0x") || publicKey.length !== 130) {
        throw new Error("Invalid public key: must be 64-byte hex string (0x + 128 chars)");
    }
    const pubKeyX = `0x${publicKey.slice(2, 66)}`;
    const pubKeyY = `0x${publicKey.slice(66, 130)}`;
    const webAuthnData = {
        pubKeyX: BigInt(pubKeyX),
        pubKeyY: BigInt(pubKeyY)
    };
    if (!validateWebAuthnKey(webAuthnData)) {
        throw new Error("Invalid WebAuthn key: coordinates are not on secp256r1 curve");
    }
    const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);
    return calculateAddressInternal({
        authenticatorIdHash,
        contractAddresses,
        index,
        webAuthnData
    });
}
function calculateWalletAddress(params) {
    return processWalletAddressParams(params, V2_CONTRACT_ADDRESSES);
}
function calculateV1Address(params) {
    return processWalletAddressParams(params, V1_CONTRACT_ADDRESSES);
}
function generateAuthenticatorIdHash(credentialId) {
    const padding = "=".repeat((4 - credentialId.length % 4) % 4);
    const base64 = credentialId.replace(/-/g, "+").replace(/_/g, "/") + padding;
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    for(let i = 0; i < binaryString.length; i++){
        bytes[i] = binaryString.charCodeAt(i);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])(bytes);
}
function validateWebAuthnKey(webAuthnData) {
    const SECP256R1_P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;
    const SECP256R1_B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;
    const { pubKeyX, pubKeyY } = webAuthnData;
    if (pubKeyX === 0n || pubKeyY === 0n || pubKeyX >= SECP256R1_P || pubKeyY >= SECP256R1_P) {
        return false;
    }
    const ySquared = pubKeyY * pubKeyY % SECP256R1_P;
    const xCubed = pubKeyX * pubKeyX * pubKeyX % SECP256R1_P;
    const threeX = 3n * pubKeyX % SECP256R1_P;
    const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;
    return ySquared === rightSide;
}
function calculateAddressInternal(params) {
    const { webAuthnData, authenticatorIdHash, index, contractAddresses } = params;
    const factoryAddress = contractAddresses.FACTORY;
    const accountImplementation = contractAddresses.ACCOUNT_IMPLEMENTATION;
    const webAuthnValidator = contractAddresses.WEBAUTHN_VALIDATOR;
    const attester = contractAddresses.ATTESTER;
    const bootstrapper = contractAddresses.BOOTSTRAPPER;
    const registry = contractAddresses.REGISTRY;
    const salt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodePacked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodePacked"])([
        "uint256",
        "uint256",
        "bytes32",
        "uint256"
    ], [
        webAuthnData.pubKeyX,
        webAuthnData.pubKeyY,
        authenticatorIdHash,
        index
    ]));
    const validatorInitData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeAbiParameters"])([
        {
            components: [
                {
                    name: "pubKeyX",
                    type: "uint256"
                },
                {
                    name: "pubKeyY",
                    type: "uint256"
                }
            ],
            type: "tuple"
        },
        {
            type: "bytes32"
        }
    ], [
        webAuthnData,
        authenticatorIdHash
    ]);
    const registryConfig = {
        attesters: [
            attester
        ],
        registry,
        threshold: 1n
    };
    const bootstrapCall = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
        abi: [
            {
                inputs: [
                    {
                        name: "validator",
                        type: "address"
                    },
                    {
                        name: "validatorInitData",
                        type: "bytes"
                    },
                    {
                        components: [
                            {
                                name: "registry",
                                type: "address"
                            },
                            {
                                name: "attesters",
                                type: "address[]"
                            },
                            {
                                name: "threshold",
                                type: "uint8"
                            }
                        ],
                        name: "registryConfig",
                        type: "tuple"
                    }
                ],
                name: "initNexusWithSingleValidator",
                type: "function"
            }
        ],
        args: [
            webAuthnValidator,
            validatorInitData,
            registryConfig
        ],
        functionName: "initNexusWithSingleValidator"
    });
    const initData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeAbiParameters"])([
        {
            type: "address"
        },
        {
            type: "bytes"
        }
    ], [
        bootstrapper,
        bootstrapCall
    ]);
    return predictProxyAddress(accountImplementation, salt, initData, factoryAddress);
}
function predictProxyAddress(implementation, salt, initData, deployer) {
    const initializeCall = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeFunctionData$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeFunctionData"])({
        abi: [
            {
                inputs: [
                    {
                        name: "data",
                        type: "bytes"
                    }
                ],
                name: "initializeAccount",
                type: "function"
            }
        ],
        args: [
            initData
        ],
        functionName: "initializeAccount"
    });
    const constructorArgs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeAbiParameters"])([
        {
            type: "address"
        },
        {
            type: "bytes"
        }
    ], [
        implementation,
        initializeCall
    ]);
    const nexusProxyCreationCode = "0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033";
    const initCodeHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$abi$2f$encodePacked$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodePacked"])([
        "bytes",
        "bytes"
    ], [
        nexusProxyCreationCode,
        constructorArgs
    ]));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getContractAddress$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCreate2Address"])({
        bytecodeHash: initCodeHash,
        from: deployer,
        salt
    });
}
// src/utils/ens.ts
async function reverseResolveEns(address) {
    try {
        const response = await fetch(`${ENS_API_URL}/reverse/${address}`);
        if (!response.ok) {
            throw new Error(`ENS API request failed: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();
        return {
            address: data.address,
            name: data.name || null
        };
    } catch (error) {
        console.error("Failed to resolve ENS name:", error);
        return {
            address,
            name: null
        };
    }
}
;
var POPUP_WIDTH2 = 420;
var POPUP_HEIGHT2 = 650;
var openPopup = (url)=>{
    const left = (window.innerWidth - POPUP_WIDTH2) / 2 + window.screenX;
    const top = (window.innerHeight - POPUP_HEIGHT2) / 2 + window.screenY;
    const popupId = `wallet_${window?.crypto?.randomUUID()}`;
    const popup = window.open(url, popupId, `width=${POPUP_WIDTH2}, height=${POPUP_HEIGHT2}, left=${left}, top=${top}`);
    popup?.focus();
    if (!popup) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].internal("Pop up window failed to open");
    }
    return popup;
};
var closePopup = (popup)=>{
    if (popup && !popup.closed) {
        popup.opener?.focus();
        popup.close();
    }
};
// src/utils/strings.ts
var hexStringFromNumber = (num)=>{
    return `0x${BigInt(num).toString(16)}`;
};
var safeJsonStringify = (obj)=>JSON.stringify(obj, (_, value)=>typeof value === "bigint" ? value.toString() + "n" : value, 2);
// src/communicator.ts
var Communicator = class {
    constructor({ appMetadata, onDisconnectCallback }){
        this.popup = null;
        this.listeners = /* @__PURE__ */ new Map();
        // posts a message to the popup window
        this.postMessage = async (message)=>{
            const popup = await this.waitForPopupLoaded();
            popup.postMessage(message, this.url.origin);
        };
        // posts a request to the popup window and waits for a response
        this.postRequestAndWaitForResponse = async (request)=>{
            const responsePromise = this.onMessage(({ requestId })=>requestId === request.requestId);
            this.postMessage(request);
            return await responsePromise;
        };
        // listens for messages from the popup window that match a given predicate
        this.onMessage = (predicate)=>{
            return new Promise((resolve, reject)=>{
                const listener = (event)=>{
                    if (event.origin !== this.url.origin) return;
                    const message = event.data;
                    if (predicate(message)) {
                        resolve(message);
                        window.removeEventListener("message", listener);
                        this.listeners.delete(listener);
                    }
                };
                window.addEventListener("message", listener);
                this.listeners.set(listener, {
                    reject
                });
            });
        };
        // closes the popup, rejects all requests and clears event listeners
        this.onRequestCancelled = ()=>{
            closePopup(this.popup);
            this.popup = null;
            this.listeners.forEach(({ reject }, listener)=>{
                reject(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].userRejectedRequest());
                window.removeEventListener("message", listener);
            });
            this.listeners.clear();
        };
        // waits for the popup window to fully load and then sends a version message
        this.waitForPopupLoaded = ()=>{
            if (this.popup && !this.popup.closed) {
                this.popup.focus();
                return Promise.resolve(this.popup);
            }
            this.popup = openPopup(this.url);
            this.onMessage(({ event })=>event === "POPUP_UNLOADED" /* POPUP_UNLOADED */ ).then(this.onRequestCancelled).catch(()=>{});
            this.onMessage(({ event })=>event === "SDK_DISCONNECT" /* SDK_DISCONNECT */ ).then(()=>{
                this.onDisconnectCallback?.();
                this.onRequestCancelled();
            }).catch(()=>{});
            return this.onMessage(({ event })=>event === "POPUP_LOADED" /* POPUP_LOADED */ ).then((message)=>{
                this.postMessage({
                    chainId: DEFAULT_CHAIN_ID,
                    data: {
                        appMetadata: this.appMetadata,
                        origin: window.location.origin,
                        sdkVersion: SDK_VERSION
                    },
                    event: "POPUP_APP_CONTEXT" /* POPUP_APP_CONTEXT */ ,
                    origin: window.location.origin,
                    requestId: message.requestId
                });
            }).then(()=>{
                if (!this.popup) throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].internal();
                return this.popup;
            });
        };
        this.url = new URL(SDK_BACKEND_URL);
        this.appMetadata = appMetadata;
        this.onDisconnectCallback = onDisconnectCallback;
    }
};
;
// src/storage/storage.ts
var memoryStorage = {};
var GeminiStorage = class {
    constructor({ scope = "@gemini", module = "wallet" } = {}){
        this.scope = scope;
        this.module = module;
    }
    scopedKey(key) {
        return `${this.scope}.${this.module}.${key}`;
    }
    async storeObject(key, item) {
        const json = safeJsonStringify(item);
        await this.setItem(key, json);
    }
    async loadObject(key, fallback) {
        const item = await this.getItem(key);
        if (!item) {
            await this.storeObject(key, fallback);
            return fallback;
        }
        try {
            return JSON.parse(item);
        } catch (error) {
            console.error(`Error parsing JSON for key ${key}:`, error);
            return fallback;
        }
    }
    // eslint-disable-next-line require-await
    async setItem(key, value) {
        const scoped = this.scopedKey(key);
        try {
            localStorage.setItem(scoped, value);
        } catch (e) {
            console.warn("localStorage not available, using memory storage", e);
            memoryStorage[scoped] = value;
        }
    }
    // eslint-disable-next-line require-await
    async getItem(key) {
        const scoped = this.scopedKey(key);
        try {
            return localStorage.getItem(scoped);
        } catch (e) {
            console.warn("localStorage not available, using memory storage", e);
            return memoryStorage[scoped] || null;
        }
    }
    // eslint-disable-next-line require-await
    async removeItem(key) {
        const scoped = this.scopedKey(key);
        try {
            localStorage.removeItem(scoped);
        } catch (e) {
            console.warn("localStorage not available, using memory storage", e);
            delete memoryStorage[scoped];
        }
    }
    async removeItems(keys) {
        await Promise.all(keys.map((key)=>this.removeItem(key)));
    }
};
// src/storage/storageInterface.ts
var STORAGE_ETH_ACCOUNTS_KEY = "eth-accounts";
var STORAGE_ETH_ACTIVE_CHAIN_KEY = "eth-active-chain";
var STORAGE_PASSKEY_CREDENTIAL_KEY = "passkey-credential";
var STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY = "preserved-passkey-credentials";
var STORAGE_SMART_ACCOUNT_KEY = "smart-account";
var STORAGE_SETTINGS_KEY = "settings";
var STORAGE_WC_REQUESTS_KEY = "wc-requests";
// src/wallets/wallet.ts
function isChainSupportedByGeminiSw(chainId) {
    return SUPPORTED_CHAIN_IDS.includes(chainId);
}
var GeminiWallet = class {
    constructor({ appMetadata, chain, onDisconnectCallback, storage }){
        this.accounts = [];
        this.chain = {
            id: DEFAULT_CHAIN_ID
        };
        this.communicator = new Communicator({
            appMetadata,
            onDisconnectCallback
        });
        this.storage = storage || new GeminiStorage();
        const fallbackChainId = chain?.id ?? DEFAULT_CHAIN_ID;
        const fallbackRpcUrl = chain?.rpcUrl ?? getDefaultRpcUrl(fallbackChainId);
        const defaultChain = {
            id: fallbackChainId,
            rpcUrl: fallbackRpcUrl
        };
        this.initPromise = this.initializeFromStorage(defaultChain);
    }
    async initializeFromStorage(defaultChain) {
        const fallbackChain = {
            ...defaultChain,
            rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id)
        };
        const [storedChain, storedAccounts] = await Promise.all([
            this.storage.loadObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, fallbackChain),
            this.storage.loadObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts)
        ]);
        this.chain = {
            ...storedChain,
            rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id)
        };
        this.accounts = storedAccounts;
    }
    async ensureInitialized() {
        await this.initPromise;
    }
    async connect() {
        await this.ensureInitialized();
        const response = await this.sendMessageToPopup({
            chainId: this.chain.id,
            event: "SDK_CONNECT" /* SDK_CONNECT */ ,
            origin: window.location.origin
        });
        this.accounts = response.data.address ? [
            response.data.address
        ] : [];
        await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);
        return this.accounts;
    }
    async disconnect() {
        await this.ensureInitialized();
        this.accounts = [];
        await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);
    }
    async switchChain({ id }) {
        await this.ensureInitialized();
        if (isChainSupportedByGeminiSw(id)) {
            this.chain = {
                id,
                rpcUrl: getDefaultRpcUrl(id)
            };
            await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);
            return null;
        }
        const response = await this.sendMessageToPopup({
            chainId: this.chain.id,
            data: id,
            event: "SDK_SWITCH_CHAIN" /* SDK_SWITCH_CHAIN */ ,
            origin: window.location.origin
        });
        return response.data.error ?? "Unsupported chain.";
    }
    async sendTransaction(txData) {
        await this.ensureInitialized();
        const response = await this.sendMessageToPopup({
            chainId: this.chain.id,
            data: txData,
            event: "SDK_SEND_TRANSACTION" /* SDK_SEND_TRANSACTION */ ,
            origin: window.location.origin
        });
        return response.data;
    }
    async signData({ message }) {
        await this.ensureInitialized();
        const response = await this.sendMessageToPopup({
            chainId: this.chain.id,
            data: {
                message
            },
            event: "SDK_SIGN_DATA" /* SDK_SIGN_DATA */ ,
            origin: window.location.origin
        });
        return response.data;
    }
    async signTypedData({ message, types, primaryType, domain }) {
        await this.ensureInitialized();
        const response = await this.sendMessageToPopup({
            chainId: this.chain.id,
            data: {
                domain,
                message,
                primaryType,
                types
            },
            event: "SDK_SIGN_TYPED_DATA" /* SDK_SIGN_TYPED_DATA */ ,
            origin: window.location.origin
        });
        return response.data;
    }
    async openSettings() {
        await this.ensureInitialized();
        await this.sendMessageToPopup({
            chainId: this.chain.id,
            data: {},
            event: "SDK_OPEN_SETTINGS" /* SDK_OPEN_SETTINGS */ ,
            origin: window.location.origin
        });
    }
    sendMessageToPopup(request) {
        return this.communicator.postRequestAndWaitForResponse({
            ...request,
            requestId: window?.crypto?.randomUUID()
        });
    }
};
;
;
var fetchRpcRequest = async (request, rpcUrl)=>{
    const requestBody = {
        ...request,
        id: window?.crypto?.randomUUID(),
        jsonrpc: "2.0"
    };
    const res = await window.fetch(rpcUrl, {
        body: JSON.stringify(requestBody),
        headers: {
            "Content-Type": "application/json"
        },
        method: "POST",
        mode: "cors"
    });
    const { result, error } = await res.json();
    if (error) throw error;
    return result;
};
function validateRpcRequestArgs(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].invalidParams({
            message: "Expected a single, non-array, object argument."
        });
    }
    const { method, params } = args;
    if (typeof method !== "string" || method.length === 0) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].invalidParams({
            message: "'args.method' must be a non-empty string."
        });
    }
    if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].invalidParams({
            message: "'args.params' must be an object or array if provided."
        });
    }
}
function convertSendValuesToBigInt(tx) {
    const FIELDS_TO_NORMALIZE = [
        "value",
        "gas",
        "gasPrice",
        "maxPriorityFeePerGas",
        "maxFeePerGas"
    ];
    const normalized = {
        ...tx
    };
    for (const field of FIELDS_TO_NORMALIZE){
        if (!(field in tx)) continue;
        const value = tx[field];
        if (typeof value === "bigint") continue;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHex"])(value)) {
            normalized[field] = BigInt(value);
        }
    }
    return normalized;
}
// src/provider/provider.ts
var GeminiWalletProvider = class extends ProviderEventEmitter {
    constructor(providerConfig){
        super();
        this.wallet = null;
        this.config = providerConfig;
        const userDisconnectCallback = providerConfig.onDisconnectCallback;
        this.wallet = new GeminiWallet({
            ...providerConfig,
            onDisconnectCallback: ()=>{
                userDisconnectCallback?.();
                this.disconnect();
            }
        });
    }
    async request(args) {
        try {
            validateRpcRequestArgs(args);
            if (!this.wallet?.accounts?.length) {
                switch(args.method){
                    case "eth_requestAccounts":
                        {
                            if (!this.wallet) {
                                const userDisconnectCallback = this.config.onDisconnectCallback;
                                this.wallet = new GeminiWallet({
                                    ...this.config,
                                    onDisconnectCallback: ()=>{
                                        userDisconnectCallback?.();
                                        this.disconnect();
                                    }
                                });
                            }
                            await this.wallet.connect();
                            this.emit("accountsChanged", this.wallet.accounts);
                            break;
                        }
                    case "net_version":
                        return DEFAULT_CHAIN_ID;
                    case "eth_chainId":
                        return hexStringFromNumber(DEFAULT_CHAIN_ID);
                    default:
                        {
                            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].unauthorized();
                        }
                }
            }
            let response;
            let requestParams;
            switch(args.method){
                case "eth_requestAccounts":
                case "eth_accounts":
                    response = this.wallet.accounts;
                    break;
                case "net_version":
                    response = this.wallet.chain.id;
                    break;
                case "eth_chainId":
                    response = hexStringFromNumber(this.wallet.chain.id);
                    break;
                case "personal_sign":
                case "wallet_sign":
                    requestParams = args.params;
                    response = await this.wallet.signData({
                        account: requestParams[1],
                        message: requestParams[0]
                    });
                    if (response.error) {
                        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].transactionRejected(response.error);
                    } else {
                        response = response.hash;
                    }
                    break;
                case "eth_sendTransaction":
                case "wallet_sendTransaction":
                    requestParams = args.params;
                    requestParams = convertSendValuesToBigInt(requestParams[0]);
                    response = await this.wallet.sendTransaction(requestParams);
                    if (response.error) {
                        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].transactionRejected(response.error);
                    } else {
                        response = response.hash;
                    }
                    break;
                case "wallet_switchEthereumChain":
                    {
                        const rawParams = args.params;
                        let chainId;
                        if (Array.isArray(rawParams) && rawParams[0]?.chainId) {
                            chainId = parseInt(rawParams[0].chainId, 16);
                        } else if (rawParams && typeof rawParams === "object" && "id" in rawParams && Number.isInteger(rawParams.id)) {
                            chainId = rawParams.id;
                        } else {
                            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].invalidParams("Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.");
                        }
                        response = await this.wallet.switchChain({
                            id: chainId
                        });
                        if (response) {
                            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].custom({
                                code: 4902,
                                message: response
                            });
                        }
                        await this.emit("chainChanged", hexStringFromNumber(chainId));
                        break;
                    }
                case "eth_signTypedData_v1":
                case "eth_signTypedData_v2":
                case "eth_signTypedData_v3":
                case "eth_signTypedData_v4":
                case "eth_signTypedData":
                    {
                        requestParams = args.params;
                        const signedTypedDataParams = JSON.parse(requestParams[1]);
                        response = await this.wallet.signTypedData({
                            account: requestParams[0],
                            domain: signedTypedDataParams.domain,
                            message: signedTypedDataParams.message,
                            primaryType: signedTypedDataParams.primaryType,
                            types: signedTypedDataParams.types
                        });
                        if (response.error) {
                            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].transactionRejected(response.error);
                        } else {
                            response = response.hash;
                        }
                        break;
                    }
                // TODO: not yet implemented or unclear if we support
                case "eth_ecRecover":
                case "eth_subscribe":
                case "eth_unsubscribe":
                case "personal_ecRecover":
                case "eth_signTransaction":
                case "wallet_watchAsset":
                case "wallet_sendCalls":
                case "wallet_getCallsStatus":
                case "wallet_getCapabilities":
                case "wallet_showCallsStatus":
                case "wallet_grantPermissions":
                    throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].methodNotSupported("Not yet implemented.");
                // not supported
                case "eth_sign":
                case "eth_coinbase":
                case "wallet_addEthereumChain":
                    throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].methodNotSupported();
                // call rpc directly for everything else
                default:
                    if (!this.wallet.chain.rpcUrl) throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$errors$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].internal(`RPC URL missing for current chain (${this.wallet.chain.id})`);
                    return fetchRpcRequest(args, this.wallet.chain.rpcUrl);
            }
            return response;
        } catch (error) {
            const { code } = error;
            if (code === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$error$2d$constants$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["errorCodes"].provider.unauthorized) this.disconnect();
            return Promise.reject((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$rpc$2d$errors$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeError"])(error));
        }
    }
    // custom wallet function to open settings page
    async openSettings() {
        await this.wallet?.openSettings();
    }
    async disconnect() {
        if (this.wallet) {
            const storage = this.config.storage || new GeminiStorage();
            await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);
            await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);
        }
        this.wallet = null;
        this.config.onDisconnectCallback?.();
        await this.emit("disconnect", "User initiated disconnection");
        await this.emit("accountsChanged", []);
    }
};
;
 //# sourceMappingURL=index.js.map
}),
];

//# sourceMappingURL=node_modules_9a6ccac6._.js.map